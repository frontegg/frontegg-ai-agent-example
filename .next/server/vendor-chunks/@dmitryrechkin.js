"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dmitryrechkin";
exports.ids = ["vendor-chunks/@dmitryrechkin"];
exports.modules = {

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONSchemaToZod: () => (/* binding */ JSONSchemaToZod)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var _Type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\");\n\n\nclass JSONSchemaToZod {\n    /**\n     * Converts a JSON schema to a Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodSchema} - The Zod schema.\n     */\n    static convert(schema) {\n        return this.parseSchema(schema);\n    }\n    /**\n     * Checks if data matches a condition schema.\n     *\n     * @param {JSONValue} data - The data to check.\n     * @param {JSONSchema} condition - The condition schema.\n     * @returns {boolean} - Whether the data matches the condition.\n     */\n    static matchesCondition(data, condition) {\n        // If no properties to check, condition is met\n        if (!condition.properties) {\n            return true;\n        }\n        // If data is not an object or is null, it can't match a schema with properties\n        if (typeof data !== 'object' || data === null || Array.isArray(data)) {\n            return false;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Check all property conditions\n        for (const [key, propCondition] of Object.entries(condition.properties)) {\n            // If property doesn't exist in data\n            if (!(key in objectData)) {\n                // If there's a const condition and property is missing, it doesn't match\n                if ('const' in propCondition) {\n                    return false;\n                }\n                // For other conditions, skip this property\n                continue;\n            }\n            const value = objectData[key];\n            // Check for const condition\n            if ('const' in propCondition && value !== propCondition['const']) {\n                return false;\n            }\n            // Check for minimum condition\n            if ('minimum' in propCondition && typeof value === 'number' && value < propCondition['minimum']) {\n                return false;\n            }\n            // Check for maximum condition\n            if ('maximum' in propCondition && typeof value === 'number' && value > propCondition['maximum']) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validates data against a conditional schema and adds issues to context if validation fails.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The conditional schema.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateConditionalSchema(data, schema, ctx) {\n        this.validateRequiredProperties(data, schema, ctx);\n        this.validatePropertyPatterns(data, schema, ctx);\n        this.validateNestedConditions(data, schema, ctx);\n    }\n    /**\n     * Validates that all required properties are present in the data.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing required properties.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateRequiredProperties(data, schema, ctx) {\n        if (!schema.required) {\n            return;\n        }\n        // If data is not an object or is null, all required properties are missing\n        if (typeof data !== 'object' || data === null) {\n            for (const requiredProp of schema.required) {\n                ctx.addIssue({\n                    code: zod__WEBPACK_IMPORTED_MODULE_1__.z.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n            return;\n        }\n        // Now we know data is an object (either a plain object or an array)\n        for (const requiredProp of schema.required) {\n            if (!(requiredProp in data)) {\n                ctx.addIssue({\n                    code: zod__WEBPACK_IMPORTED_MODULE_1__.z.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n        }\n    }\n    /**\n     * Validates property patterns for string properties.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing property patterns.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validatePropertyPatterns(data, schema, ctx) {\n        if (!schema.properties) {\n            return;\n        }\n        // If data is not an object or is null, we can't validate property patterns\n        if (typeof data !== 'object' || data === null) {\n            return;\n        }\n        // If data is an array, we can't validate property patterns\n        if (Array.isArray(data)) {\n            return;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Process each property in the schema\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            // Skip if property doesn't exist in data\n            if (!(key in objectData)) {\n                continue;\n            }\n            const value = objectData[key];\n            // Check pattern validation for strings\n            if (propSchema['pattern'] && typeof value === 'string') {\n                const regex = new RegExp(propSchema['pattern']);\n                if (!regex.test(value)) {\n                    ctx.addIssue({\n                        code: zod__WEBPACK_IMPORTED_MODULE_1__.z.ZodIssueCode.custom,\n                        message: `String '${value}' does not match pattern '${propSchema['pattern']}'`,\n                        path: [key]\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Validates nested if-then-else conditions.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing if-then-else conditions.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateNestedConditions(data, schema, ctx) {\n        if (!schema['if'] || !schema['then']) {\n            return;\n        }\n        const matchesIf = this.matchesCondition(data, schema['if']);\n        if (matchesIf) {\n            this.validateConditionalSchema(data, schema['then'], ctx);\n        }\n        else if (schema['else']) {\n            this.validateConditionalSchema(data, schema['else'], ctx);\n        }\n    }\n    /**\n     * Parses a JSON schema and returns the corresponding Zod schema.\n     * This is the main entry point for schema conversion.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseSchema(schema) {\n        // Handle array of types (e.g., ['string', 'null'] for nullable types)\n        if (Array.isArray(schema.type)) {\n            return this.handleTypeArray(schema);\n        }\n        // Handle combinators (oneOf, anyOf, allOf)\n        if (schema.oneOf || schema.anyOf || schema.allOf) {\n            return this.parseCombinator(schema);\n        }\n        // Handle if-then-else conditional validation\n        if (schema['if'] && schema['then']) {\n            return this.parseObject(schema);\n        }\n        // Handle object schema without explicit type but with properties\n        if (schema.properties && (!schema.type || schema.type === 'object')) {\n            return this.parseObject(schema);\n        }\n        // Handle all other types\n        return this.handleSingleType(schema);\n    }\n    /**\n     * Handles schemas with an array of types.\n     *\n     * @param {JSONSchema} schema - The JSON schema with type array.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleTypeArray(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Check if the type array includes 'null' to create a nullable type\n        if (schema.type.includes('null')) {\n            return this.handleNullableType(schema);\n        }\n        // If no 'null' in the type array, handle as a union of types\n        return this.createUnionFromTypes(schema.type, schema);\n    }\n    /**\n     * Handles nullable types by creating a nullable schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema with nullable type.\n     * @returns {ZodTypeAny} - The nullable Zod schema.\n     */\n    static handleNullableType(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Create a copy of the schema without the 'null' type\n        const nonNullSchema = { ...schema };\n        nonNullSchema.type = schema.type.filter(t => t !== 'null');\n        // If there's only one type left, handle it as a single type and make it nullable\n        if (nonNullSchema.type.length === 1) {\n            const singleTypeSchema = this.handleSingleType({ ...schema, type: nonNullSchema.type[0] });\n            return singleTypeSchema.nullable();\n        }\n        // If multiple non-null types, create a union and make it nullable\n        const unionSchema = this.parseSchema(nonNullSchema);\n        return unionSchema.nullable();\n    }\n    /**\n     * Creates a union type from an array of types.\n     *\n     * @param {string[]} types - Array of type strings.\n     * @param {JSONSchema} baseSchema - The base schema to apply to each type.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromTypes(types, baseSchema) {\n        const schemas = types.map(type => {\n            const singleTypeSchema = { ...baseSchema, type };\n            return this.parseSchema(singleTypeSchema);\n        });\n        return zod__WEBPACK_IMPORTED_MODULE_1__.z.union(schemas);\n    }\n    /**\n     * Handles schemas with a single type.\n     *\n     * @param {JSONSchema} schema - The JSON schema with single type.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleSingleType(schema) {\n        // Handle schemas without a type property\n        if (schema.type === undefined) {\n            // Check for combinators first\n            if (schema.oneOf || schema.anyOf || schema.allOf) {\n                return this.parseCombinator(schema);\n            }\n            // Check for object properties\n            if (schema.properties) {\n                return this.parseObject(schema);\n            }\n            // Default to any() for schemas with no type and no other indicators\n            return zod__WEBPACK_IMPORTED_MODULE_1__.z.any();\n        }\n        // Handle specific types\n        switch (schema.type) {\n            case 'string': return this.parseString(schema);\n            case 'number':\n            case 'integer': return this.parseNumberSchema(schema);\n            case 'boolean': return zod__WEBPACK_IMPORTED_MODULE_1__.z.boolean();\n            case 'array': return this.parseArray(schema);\n            case 'object': return this.parseObject(schema);\n            default: throw new Error('Unsupported schema type');\n        }\n    }\n    /**\n     * Parses a number schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a number.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseNumberSchema(schema) {\n        let numberSchema = zod__WEBPACK_IMPORTED_MODULE_1__.z.number();\n        // Apply all number validations\n        let result = numberSchema;\n        result = this.applyNumberBounds(numberSchema, schema);\n        result = this.applyNumberMultipleOf(numberSchema, schema);\n        result = this.applyNumberEnum(numberSchema, schema);\n        result = this.applyIntegerConstraint(numberSchema, schema);\n        return result;\n    }\n    /**\n     * Applies bounds validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with bounds.\n     * @returns {z.ZodNumber} - The updated schema with bounds validation.\n     */\n    static applyNumberBounds(numberSchema, schema) {\n        let result = numberSchema;\n        if (schema['minimum'] !== undefined) {\n            result = schema['exclusiveMinimum'] ?\n                result.gt(schema['minimum']) :\n                result.gte(schema['minimum']);\n        }\n        if (schema['maximum'] !== undefined) {\n            result = schema['exclusiveMaximum'] ?\n                result.lt(schema['maximum']) :\n                result.lte(schema['maximum']);\n        }\n        return result;\n    }\n    /**\n     * Applies multipleOf validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with multipleOf.\n     * @returns {z.ZodNumber} - The updated schema with multipleOf validation.\n     */\n    static applyNumberMultipleOf(numberSchema, schema) {\n        if (schema['multipleOf'] === undefined) {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => val % schema['multipleOf'] === 0, { message: `Number must be a multiple of ${schema['multipleOf']}` });\n    }\n    /**\n     * Applies enum validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {z.ZodNumber} - The updated schema with enum validation.\n     */\n    static applyNumberEnum(numberSchema, schema) {\n        if (!schema.enum) {\n            return numberSchema;\n        }\n        // Filter out non-number values from enum\n        const numberEnums = schema.enum.filter(val => typeof val === 'number');\n        if (numberEnums.length === 0) {\n            return numberSchema;\n        }\n        // Use refinement to validate against enum values\n        return numberSchema.refine(val => numberEnums.includes(val), { message: `Number must be one of: ${numberEnums.join(', ')}` });\n    }\n    /**\n     * Applies integer constraint to a number schema if needed.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodNumber} - The updated schema with integer validation if needed.\n     */\n    static applyIntegerConstraint(numberSchema, schema) {\n        if (schema.type !== 'integer') {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => Number.isInteger(val), { message: 'Number must be an integer' });\n    }\n    /**\n     * Parses a string schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a string.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseString(schema) {\n        let stringSchema = zod__WEBPACK_IMPORTED_MODULE_1__.z.string();\n        let result = stringSchema;\n        // Apply all string validations\n        if (schema.format) {\n            // Handle format-specific string validation\n            return this.applyStringFormat(stringSchema, schema);\n        }\n        else {\n            // Only apply other validations if format is not specified\n            // or apply them to the formatted string\n            result = this.applyStringPattern(stringSchema, schema);\n            result = this.applyStringLength(stringSchema, schema);\n            result = this.applyStringEnum(stringSchema, schema);\n        }\n        return result;\n    }\n    /**\n     * Applies format validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with format.\n     * @returns {ZodTypeAny} - The updated schema with format validation.\n     */\n    static applyStringFormat(stringSchema, schema) {\n        if (!schema.format) {\n            return stringSchema;\n        }\n        switch (schema.format) {\n            case 'email':\n                return stringSchema.email();\n            case 'date-time':\n                return stringSchema.datetime();\n            case 'uri':\n                return stringSchema.url();\n            case 'uuid':\n                return stringSchema.uuid();\n            case 'date':\n                return stringSchema.date();\n            default:\n                return stringSchema;\n        }\n    }\n    /**\n     * Applies pattern validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with pattern.\n     * @returns {z.ZodString} - The updated schema with pattern validation.\n     */\n    static applyStringPattern(stringSchema, schema) {\n        if (!schema['pattern']) {\n            return stringSchema;\n        }\n        const regex = new RegExp(schema['pattern']);\n        return stringSchema.regex(regex, { message: `String must match pattern: ${schema['pattern']}` });\n    }\n    /**\n     * Applies length constraints to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with length constraints.\n     * @returns {z.ZodString} - The updated schema with length validation.\n     */\n    static applyStringLength(stringSchema, schema) {\n        let result = stringSchema;\n        if (schema['minLength'] !== undefined) {\n            stringSchema = stringSchema.min(schema['minLength']);\n        }\n        if (schema['maxLength'] !== undefined) {\n            stringSchema = stringSchema.max(schema['maxLength']);\n        }\n        return result;\n    }\n    /**\n     * Applies enum validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {ZodTypeAny} - The updated schema with enum validation.\n     */\n    static applyStringEnum(stringSchema, schema) {\n        if (!schema.enum) {\n            return stringSchema;\n        }\n        // Use refinement to validate against enum values\n        return stringSchema.refine((val) => schema.enum?.includes(val), {\n            message: `Value must be one of: ${schema.enum?.join(', ')}`\n        });\n    }\n    /**\n     * Parses a JSON schema of type array and returns the corresponding Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseArray(schema) {\n        // Handle tuple validation (items is an array)\n        if (Array.isArray(schema.items)) {\n            const tupleSchemas = schema.items.map(item => this.parseSchema(item));\n            return zod__WEBPACK_IMPORTED_MODULE_1__.z.union(tupleSchemas);\n        }\n        // Create regular array schema\n        const itemSchema = schema.items ? this.parseSchema(schema.items) : zod__WEBPACK_IMPORTED_MODULE_1__.z.any();\n        let arraySchema = zod__WEBPACK_IMPORTED_MODULE_1__.z.array(itemSchema);\n        // Apply array constraints\n        let result = arraySchema;\n        result = this.applyArrayConstraints(arraySchema, schema);\n        return result;\n    }\n    /**\n     * Applies constraints to an array schema.\n     *\n     * @param {z.ZodArray<any>} arraySchema - The base array schema.\n     * @param {JSONSchema} schema - The JSON schema with array constraints.\n     * @returns {z.ZodTypeAny} - The updated array schema with constraints.\n     */\n    static applyArrayConstraints(arraySchema, schema) {\n        // Handle minItems\n        if (schema['minItems'] !== undefined) {\n            arraySchema = arraySchema.min(schema['minItems']);\n        }\n        // Handle maxItems\n        if (schema['maxItems'] !== undefined) {\n            arraySchema = arraySchema.max(schema['maxItems']);\n        }\n        // Handle uniqueItems\n        if (schema['uniqueItems']) {\n            return arraySchema.refine((items) => new Set(items).size === items.length, { message: 'Array items must be unique' });\n        }\n        return arraySchema;\n    }\n    /**\n     * Parses an object schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseObject(schema) {\n        // Handle conditional validation (if-then-else) first\n        if (schema['if'] && schema['then']) {\n            return this.parseConditional(schema);\n        }\n        // Create shape object for Zod\n        const shape = {};\n        // Process properties\n        this.processObjectProperties(schema, shape);\n        // Create the object schema and handle additionalProperties\n        return this.processAdditionalProperties(schema, zod__WEBPACK_IMPORTED_MODULE_1__.z.object(shape));\n    }\n    /**\n     * Processes object properties and builds the shape object.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {Record<string, ZodTypeAny>} shape - The shape object to populate.\n     */\n    static processObjectProperties(schema, shape) {\n        const required = new Set(schema.required || []);\n        if (!schema.properties) {\n            return;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            const zodSchema = this.parseSchema(propSchema);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n    }\n    /**\n     * Processes additionalProperties configuration.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {z.ZodObject<any, any>} objectSchema - The Zod object schema.\n     * @returns {z.ZodObject<any, any>} - The updated Zod object schema.\n     */\n    static processAdditionalProperties(schema, objectSchema) {\n        if (schema.additionalProperties === true) {\n            return objectSchema.passthrough();\n        }\n        else if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {\n            // Handle schema for additional properties\n            const additionalPropSchema = this.parseSchema(schema.additionalProperties);\n            return objectSchema.catchall(additionalPropSchema);\n        }\n        else {\n            return objectSchema.strict();\n        }\n    }\n    /**\n     * Parses a conditional schema with if-then-else.\n     *\n     * @param {JSONSchema} schema - The JSON schema with conditional validation.\n     * @returns {ZodTypeAny} - The conditional Zod schema.\n     */\n    static parseConditional(schema) {\n        // Create base object schema\n        const zodObject = this.createBaseObjectSchema(schema);\n        // Extract conditional parts\n        const ifCondition = schema['if'];\n        const thenSchema = schema['then'];\n        const elseSchema = schema['else'];\n        // Apply conditional validation using superRefine\n        return zodObject.superRefine((data, ctx) => {\n            // Apply default values to data for condition checking\n            const dataWithDefaults = this.applyDefaultValues(data, schema);\n            // Apply appropriate validation based on condition\n            if (this.matchesCondition(dataWithDefaults, ifCondition)) {\n                this.validateConditionalSchema(dataWithDefaults, thenSchema, ctx);\n            }\n            else if (elseSchema) {\n                this.validateConditionalSchema(dataWithDefaults, elseSchema, ctx);\n            }\n        });\n    }\n    /**\n     * Creates a base object schema from the given JSON schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodObject<any, any>} - The base Zod object schema.\n     */\n    static createBaseObjectSchema(schema) {\n        const shape = {};\n        const required = new Set(schema.required || []);\n        for (const [key, value] of Object.entries(schema.properties || {})) {\n            const zodSchema = this.parseSchema(value);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n        const zodObject = zod__WEBPACK_IMPORTED_MODULE_1__.z.object(shape);\n        return this.processAdditionalProperties(schema, zodObject);\n    }\n    /**\n     * Applies default values from schema properties to data object.\n     *\n     * @param {JSONValue} data - The original data object.\n     * @param {JSONSchema} schema - The schema with default values.\n     * @returns {JSONValue} - The data object with defaults applied.\n     */\n    static applyDefaultValues(data, schema) {\n        // If data is not an object or is null, we can't apply defaults\n        if (typeof data !== 'object' || data === null) {\n            return data;\n        }\n        // If data is an array, we can't apply defaults from schema properties\n        if (Array.isArray(data)) {\n            return data;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        const dataWithDefaults = { ...objectData };\n        if (!schema.properties) {\n            return dataWithDefaults;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            if (!(key in dataWithDefaults) && 'default' in propSchema) {\n                dataWithDefaults[key] = propSchema['default'];\n            }\n        }\n        return dataWithDefaults;\n    }\n    /**\n     * Parses a schema with combinators (oneOf, anyOf, allOf).\n     * Delegates to the appropriate combinator parser based on which combinator is present.\n     *\n     * @param {JSONSchema} schema - The JSON schema with combinators.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseCombinator(schema) {\n        if (schema.oneOf) {\n            return this.parseOneOf(schema.oneOf);\n        }\n        if (schema.anyOf) {\n            return this.parseAnyOf(schema.anyOf);\n        }\n        if (schema.allOf) {\n            return this.parseAllOf(schema.allOf);\n        }\n        // Should not reach here if schema has combinators\n        throw new Error('Unsupported schema type');\n    }\n    /**\n     * Parses a oneOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the oneOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseOneOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Parses an anyOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the anyOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAnyOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Creates a union from an array of schemas, handling special cases.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas to create a union from.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromSchemas(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return zod__WEBPACK_IMPORTED_MODULE_1__.z.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Process each subschema individually\n        const zodSchemas = [];\n        for (const subSchema of schemas) {\n            // Handle null type specially\n            if (subSchema.type === 'null') {\n                zodSchemas.push(zod__WEBPACK_IMPORTED_MODULE_1__.z.null());\n            }\n            else {\n                zodSchemas.push(this.parseSchema(subSchema));\n            }\n        }\n        // Return appropriate schema based on number of valid schemas\n        if (zodSchemas.length >= 2) {\n            return zod__WEBPACK_IMPORTED_MODULE_1__.z.union(zodSchemas);\n        }\n        else if (zodSchemas.length === 1) {\n            return zodSchemas[0];\n        }\n        // Fallback if no valid schemas were created\n        return zod__WEBPACK_IMPORTED_MODULE_1__.z.any();\n    }\n    /**\n     * Parses an allOf combinator schema by merging all schemas.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the allOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAllOf(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return zod__WEBPACK_IMPORTED_MODULE_1__.z.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Merge all schemas together\n        const mergedSchema = schemas.reduce((acc, currentSchema) => this.mergeSchemas(acc, currentSchema));\n        return this.parseSchema(mergedSchema);\n    }\n    /**\n     * Merges two JSON schemas together.\n     *\n     * @param {JSONSchema} baseSchema - The base JSON schema.\n     * @param {JSONSchema} addSchema - The JSON schema to add.\n     * @returns {JSONSchema} - The merged JSON schema\n     */\n    static mergeSchemas(baseSchema, addSchema) {\n        const merged = { ...baseSchema, ...addSchema };\n        if (baseSchema.properties && addSchema.properties) {\n            const mergedProperties = { ...baseSchema.properties, ...addSchema.properties };\n            merged.properties = mergedProperties;\n        }\n        if (baseSchema.required && addSchema.required) {\n            const mergedRequired = [...new Set([...baseSchema.required, ...addSchema.required])];\n            merged.required = mergedRequired;\n        }\n        return merged;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvSlNPTlNjaGVtYVRvWm9kLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQztBQUNSO0FBQ3BCO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFDO0FBQzNCLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFDO0FBQzNCLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFlBQVk7QUFDM0IsZUFBZSxpQkFBaUI7QUFDaEM7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X21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvSlNPTlNjaGVtYVRvWm9kLmpzP2U2ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgeiwgWm9kU2NoZW1hIH0gZnJvbSAnem9kJztcbmltcG9ydCB7fSBmcm9tICcuL1R5cGUuanMnO1xuZXhwb3J0IGNsYXNzIEpTT05TY2hlbWFUb1pvZCB7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBKU09OIHNjaGVtYSB0byBhIFpvZCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kU2NoZW1hfSAtIFRoZSBab2Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYShzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZGF0YSBtYXRjaGVzIGEgY29uZGl0aW9uIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlZhbHVlfSBkYXRhIC0gVGhlIGRhdGEgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBjb25kaXRpb24gLSBUaGUgY29uZGl0aW9uIHNjaGVtYS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRoZSBkYXRhIG1hdGNoZXMgdGhlIGNvbmRpdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hlc0NvbmRpdGlvbihkYXRhLCBjb25kaXRpb24pIHtcbiAgICAgICAgLy8gSWYgbm8gcHJvcGVydGllcyB0byBjaGVjaywgY29uZGl0aW9uIGlzIG1ldFxuICAgICAgICBpZiAoIWNvbmRpdGlvbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBkYXRhIGlzIG5vdCBhbiBvYmplY3Qgb3IgaXMgbnVsbCwgaXQgY2FuJ3QgbWF0Y2ggYSBzY2hlbWEgd2l0aCBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHdlIGtub3cgZGF0YSBpcyBhIEpTT05PYmplY3RcbiAgICAgICAgY29uc3Qgb2JqZWN0RGF0YSA9IGRhdGE7XG4gICAgICAgIC8vIENoZWNrIGFsbCBwcm9wZXJ0eSBjb25kaXRpb25zXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcENvbmRpdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoY29uZGl0aW9uLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAvLyBJZiBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0IGluIGRhdGFcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmplY3REYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb25zdCBjb25kaXRpb24gYW5kIHByb3BlcnR5IGlzIG1pc3NpbmcsIGl0IGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgICAgICAgICBpZiAoJ2NvbnN0JyBpbiBwcm9wQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIG90aGVyIGNvbmRpdGlvbnMsIHNraXAgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3REYXRhW2tleV07XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY29uc3QgY29uZGl0aW9uXG4gICAgICAgICAgICBpZiAoJ2NvbnN0JyBpbiBwcm9wQ29uZGl0aW9uICYmIHZhbHVlICE9PSBwcm9wQ29uZGl0aW9uWydjb25zdCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1pbmltdW0gY29uZGl0aW9uXG4gICAgICAgICAgICBpZiAoJ21pbmltdW0nIGluIHByb3BDb25kaXRpb24gJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA8IHByb3BDb25kaXRpb25bJ21pbmltdW0nXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBtYXhpbXVtIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKCdtYXhpbXVtJyBpbiBwcm9wQ29uZGl0aW9uICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiBwcm9wQ29uZGl0aW9uWydtYXhpbXVtJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBkYXRhIGFnYWluc3QgYSBjb25kaXRpb25hbCBzY2hlbWEgYW5kIGFkZHMgaXNzdWVzIHRvIGNvbnRleHQgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlZhbHVlfSBkYXRhIC0gVGhlIGRhdGEgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgY29uZGl0aW9uYWwgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7ei5SZWZpbmVtZW50Q3R4fSBjdHggLSBUaGUgWm9kIHJlZmluZW1lbnQgY29udGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRhdGVDb25kaXRpb25hbFNjaGVtYShkYXRhLCBzY2hlbWEsIGN0eCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWlyZWRQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgY3R4KTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVByb3BlcnR5UGF0dGVybnMoZGF0YSwgc2NoZW1hLCBjdHgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlTmVzdGVkQ29uZGl0aW9ucyhkYXRhLCBzY2hlbWEsIGN0eCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IGFsbCByZXF1aXJlZCBwcm9wZXJ0aWVzIGFyZSBwcmVzZW50IGluIHRoZSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OVmFsdWV9IGRhdGEgLSBUaGUgZGF0YSB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBzY2hlbWEgY29udGFpbmluZyByZXF1aXJlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7ei5SZWZpbmVtZW50Q3R4fSBjdHggLSBUaGUgWm9kIHJlZmluZW1lbnQgY29udGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRhdGVSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBjdHgpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBkYXRhIGlzIG5vdCBhbiBvYmplY3Qgb3IgaXMgbnVsbCwgYWxsIHJlcXVpcmVkIHByb3BlcnRpZXMgYXJlIG1pc3NpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkUHJvcCBvZiBzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB6LlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXF1aXJlZCBwcm9wZXJ0eSAnJHtyZXF1aXJlZFByb3B9JyBpcyBtaXNzaW5nYCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogW3JlcXVpcmVkUHJvcF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgd2Uga25vdyBkYXRhIGlzIGFuIG9iamVjdCAoZWl0aGVyIGEgcGxhaW4gb2JqZWN0IG9yIGFuIGFycmF5KVxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkUHJvcCBvZiBzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGlmICghKHJlcXVpcmVkUHJvcCBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHouWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlcXVpcmVkIHByb3BlcnR5ICcke3JlcXVpcmVkUHJvcH0nIGlzIG1pc3NpbmdgLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBbcmVxdWlyZWRQcm9wXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBwcm9wZXJ0eSBwYXR0ZXJucyBmb3Igc3RyaW5nIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05WYWx1ZX0gZGF0YSAtIFRoZSBkYXRhIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIHNjaGVtYSBjb250YWluaW5nIHByb3BlcnR5IHBhdHRlcm5zLlxuICAgICAqIEBwYXJhbSB7ei5SZWZpbmVtZW50Q3R4fSBjdHggLSBUaGUgWm9kIHJlZmluZW1lbnQgY29udGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRhdGVQcm9wZXJ0eVBhdHRlcm5zKGRhdGEsIHNjaGVtYSwgY3R4KSB7XG4gICAgICAgIGlmICghc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBkYXRhIGlzIG5vdCBhbiBvYmplY3Qgb3IgaXMgbnVsbCwgd2UgY2FuJ3QgdmFsaWRhdGUgcHJvcGVydHkgcGF0dGVybnNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZGF0YSBpcyBhbiBhcnJheSwgd2UgY2FuJ3QgdmFsaWRhdGUgcHJvcGVydHkgcGF0dGVybnNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgd2Uga25vdyBkYXRhIGlzIGEgSlNPTk9iamVjdFxuICAgICAgICBjb25zdCBvYmplY3REYXRhID0gZGF0YTtcbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHByb3BlcnR5IGluIHRoZSBzY2hlbWFcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9wU2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIC8vIFNraXAgaWYgcHJvcGVydHkgZG9lc24ndCBleGlzdCBpbiBkYXRhXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqZWN0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0RGF0YVtrZXldO1xuICAgICAgICAgICAgLy8gQ2hlY2sgcGF0dGVybiB2YWxpZGF0aW9uIGZvciBzdHJpbmdzXG4gICAgICAgICAgICBpZiAocHJvcFNjaGVtYVsncGF0dGVybiddICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocHJvcFNjaGVtYVsncGF0dGVybiddKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiB6LlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgU3RyaW5nICcke3ZhbHVlfScgZG9lcyBub3QgbWF0Y2ggcGF0dGVybiAnJHtwcm9wU2NoZW1hWydwYXR0ZXJuJ119J2AsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBba2V5XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIG5lc3RlZCBpZi10aGVuLWVsc2UgY29uZGl0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlZhbHVlfSBkYXRhIC0gVGhlIGRhdGEgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgc2NoZW1hIGNvbnRhaW5pbmcgaWYtdGhlbi1lbHNlIGNvbmRpdGlvbnMuXG4gICAgICogQHBhcmFtIHt6LlJlZmluZW1lbnRDdHh9IGN0eCAtIFRoZSBab2QgcmVmaW5lbWVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZGF0ZU5lc3RlZENvbmRpdGlvbnMoZGF0YSwgc2NoZW1hLCBjdHgpIHtcbiAgICAgICAgaWYgKCFzY2hlbWFbJ2lmJ10gfHwgIXNjaGVtYVsndGhlbiddKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hlc0lmID0gdGhpcy5tYXRjaGVzQ29uZGl0aW9uKGRhdGEsIHNjaGVtYVsnaWYnXSk7XG4gICAgICAgIGlmIChtYXRjaGVzSWYpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDb25kaXRpb25hbFNjaGVtYShkYXRhLCBzY2hlbWFbJ3RoZW4nXSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFbJ2Vsc2UnXSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvbmRpdGlvbmFsU2NoZW1hKGRhdGEsIHNjaGVtYVsnZWxzZSddLCBjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIEpTT04gc2NoZW1hIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIFpvZCBzY2hlbWEuXG4gICAgICogVGhpcyBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3Igc2NoZW1hIGNvbnZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICAvLyBIYW5kbGUgYXJyYXkgb2YgdHlwZXMgKGUuZy4sIFsnc3RyaW5nJywgJ251bGwnXSBmb3IgbnVsbGFibGUgdHlwZXMpXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVHlwZUFycmF5KHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGNvbWJpbmF0b3JzIChvbmVPZiwgYW55T2YsIGFsbE9mKVxuICAgICAgICBpZiAoc2NoZW1hLm9uZU9mIHx8IHNjaGVtYS5hbnlPZiB8fCBzY2hlbWEuYWxsT2YpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29tYmluYXRvcihzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpZi10aGVuLWVsc2UgY29uZGl0aW9uYWwgdmFsaWRhdGlvblxuICAgICAgICBpZiAoc2NoZW1hWydpZiddICYmIHNjaGVtYVsndGhlbiddKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdChzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBvYmplY3Qgc2NoZW1hIHdpdGhvdXQgZXhwbGljaXQgdHlwZSBidXQgd2l0aCBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcyAmJiAoIXNjaGVtYS50eXBlIHx8IHNjaGVtYS50eXBlID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0KHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFsbCBvdGhlciB0eXBlc1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaW5nbGVUeXBlKHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2NoZW1hcyB3aXRoIGFuIGFycmF5IG9mIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCB0eXBlIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFuZGxlVHlwZUFycmF5KHNjaGVtYSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNjaGVtYS50eXBlIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHR5cGUgYXJyYXkgaW5jbHVkZXMgJ251bGwnIHRvIGNyZWF0ZSBhIG51bGxhYmxlIHR5cGVcbiAgICAgICAgaWYgKHNjaGVtYS50eXBlLmluY2x1ZGVzKCdudWxsJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZU51bGxhYmxlVHlwZShzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vICdudWxsJyBpbiB0aGUgdHlwZSBhcnJheSwgaGFuZGxlIGFzIGEgdW5pb24gb2YgdHlwZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVW5pb25Gcm9tVHlwZXMoc2NoZW1hLnR5cGUsIHNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbnVsbGFibGUgdHlwZXMgYnkgY3JlYXRpbmcgYSBudWxsYWJsZSBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIG51bGxhYmxlIHR5cGUuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIG51bGxhYmxlIFpvZCBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGhhbmRsZU51bGxhYmxlVHlwZShzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzY2hlbWEudHlwZSB0byBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHNjaGVtYSB3aXRob3V0IHRoZSAnbnVsbCcgdHlwZVxuICAgICAgICBjb25zdCBub25OdWxsU2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICAgICAgbm9uTnVsbFNjaGVtYS50eXBlID0gc2NoZW1hLnR5cGUuZmlsdGVyKHQgPT4gdCAhPT0gJ251bGwnKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSB0eXBlIGxlZnQsIGhhbmRsZSBpdCBhcyBhIHNpbmdsZSB0eXBlIGFuZCBtYWtlIGl0IG51bGxhYmxlXG4gICAgICAgIGlmIChub25OdWxsU2NoZW1hLnR5cGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBzaW5nbGVUeXBlU2NoZW1hID0gdGhpcy5oYW5kbGVTaW5nbGVUeXBlKHsgLi4uc2NoZW1hLCB0eXBlOiBub25OdWxsU2NoZW1hLnR5cGVbMF0gfSk7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlVHlwZVNjaGVtYS5udWxsYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG11bHRpcGxlIG5vbi1udWxsIHR5cGVzLCBjcmVhdGUgYSB1bmlvbiBhbmQgbWFrZSBpdCBudWxsYWJsZVxuICAgICAgICBjb25zdCB1bmlvblNjaGVtYSA9IHRoaXMucGFyc2VTY2hlbWEobm9uTnVsbFNjaGVtYSk7XG4gICAgICAgIHJldHVybiB1bmlvblNjaGVtYS5udWxsYWJsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdW5pb24gdHlwZSBmcm9tIGFuIGFycmF5IG9mIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdHlwZXMgLSBBcnJheSBvZiB0eXBlIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBiYXNlU2NoZW1hIC0gVGhlIGJhc2Ugc2NoZW1hIHRvIGFwcGx5IHRvIGVhY2ggdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgdW5pb24gWm9kIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVW5pb25Gcm9tVHlwZXModHlwZXMsIGJhc2VTY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hcyA9IHR5cGVzLm1hcCh0eXBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVR5cGVTY2hlbWEgPSB7IC4uLmJhc2VTY2hlbWEsIHR5cGUgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hKHNpbmdsZVR5cGVTY2hlbWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHoudW5pb24oc2NoZW1hcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2NoZW1hcyB3aXRoIGEgc2luZ2xlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIHNpbmdsZSB0eXBlLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFuZGxlU2luZ2xlVHlwZShzY2hlbWEpIHtcbiAgICAgICAgLy8gSGFuZGxlIHNjaGVtYXMgd2l0aG91dCBhIHR5cGUgcHJvcGVydHlcbiAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb21iaW5hdG9ycyBmaXJzdFxuICAgICAgICAgICAgaWYgKHNjaGVtYS5vbmVPZiB8fCBzY2hlbWEuYW55T2YgfHwgc2NoZW1hLmFsbE9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb21iaW5hdG9yKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0KHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGFueSgpIGZvciBzY2hlbWFzIHdpdGggbm8gdHlwZSBhbmQgbm8gb3RoZXIgaW5kaWNhdG9yc1xuICAgICAgICAgICAgcmV0dXJuIHouYW55KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIHR5cGVzXG4gICAgICAgIHN3aXRjaCAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKHNjaGVtYSk7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnaW50ZWdlcic6IHJldHVybiB0aGlzLnBhcnNlTnVtYmVyU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzogcmV0dXJuIHouYm9vbGVhbigpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOiByZXR1cm4gdGhpcy5wYXJzZUFycmF5KHNjaGVtYSk7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gdGhpcy5wYXJzZU9iamVjdChzY2hlbWEpO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzY2hlbWEgdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIG51bWJlciBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSBmb3IgYSBudW1iZXIuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZU51bWJlclNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgbGV0IG51bWJlclNjaGVtYSA9IHoubnVtYmVyKCk7XG4gICAgICAgIC8vIEFwcGx5IGFsbCBudW1iZXIgdmFsaWRhdGlvbnNcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bWJlclNjaGVtYTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseU51bWJlckJvdW5kcyhudW1iZXJTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlOdW1iZXJNdWx0aXBsZU9mKG51bWJlclNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseU51bWJlckVudW0obnVtYmVyU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5SW50ZWdlckNvbnN0cmFpbnQobnVtYmVyU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGJvdW5kcyB2YWxpZGF0aW9uIHRvIGEgbnVtYmVyIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2ROdW1iZXJ9IG51bWJlclNjaGVtYSAtIFRoZSBiYXNlIG51bWJlciBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBib3VuZHMuXG4gICAgICogQHJldHVybnMge3ouWm9kTnVtYmVyfSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIGJvdW5kcyB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseU51bWJlckJvdW5kcyhudW1iZXJTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVtYmVyU2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hWydtaW5pbXVtJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2NoZW1hWydleGNsdXNpdmVNaW5pbXVtJ10gP1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ndChzY2hlbWFbJ21pbmltdW0nXSkgOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5ndGUoc2NoZW1hWydtaW5pbXVtJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFbJ21heGltdW0nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzY2hlbWFbJ2V4Y2x1c2l2ZU1heGltdW0nXSA/XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmx0KHNjaGVtYVsnbWF4aW11bSddKSA6XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmx0ZShzY2hlbWFbJ21heGltdW0nXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBtdWx0aXBsZU9mIHZhbGlkYXRpb24gdG8gYSBudW1iZXIgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZE51bWJlcn0gbnVtYmVyU2NoZW1hIC0gVGhlIGJhc2UgbnVtYmVyIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIG11bHRpcGxlT2YuXG4gICAgICogQHJldHVybnMge3ouWm9kTnVtYmVyfSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIG11bHRpcGxlT2YgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlOdW1iZXJNdWx0aXBsZU9mKG51bWJlclNjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWFbJ211bHRpcGxlT2YnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1iZXJTY2hlbWEucmVmaW5lKHZhbCA9PiB2YWwgJSBzY2hlbWFbJ211bHRpcGxlT2YnXSA9PT0gMCwgeyBtZXNzYWdlOiBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke3NjaGVtYVsnbXVsdGlwbGVPZiddfWAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZW51bSB2YWxpZGF0aW9uIHRvIGEgbnVtYmVyIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2ROdW1iZXJ9IG51bWJlclNjaGVtYSAtIFRoZSBiYXNlIG51bWJlciBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBlbnVtLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZE51bWJlcn0gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBlbnVtIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5TnVtYmVyRW51bShudW1iZXJTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlciBvdXQgbm9uLW51bWJlciB2YWx1ZXMgZnJvbSBlbnVtXG4gICAgICAgIGNvbnN0IG51bWJlckVudW1zID0gc2NoZW1hLmVudW0uZmlsdGVyKHZhbCA9PiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyk7XG4gICAgICAgIGlmIChudW1iZXJFbnVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHJlZmluZW1lbnQgdG8gdmFsaWRhdGUgYWdhaW5zdCBlbnVtIHZhbHVlc1xuICAgICAgICByZXR1cm4gbnVtYmVyU2NoZW1hLnJlZmluZSh2YWwgPT4gbnVtYmVyRW51bXMuaW5jbHVkZXModmFsKSwgeyBtZXNzYWdlOiBgTnVtYmVyIG11c3QgYmUgb25lIG9mOiAke251bWJlckVudW1zLmpvaW4oJywgJyl9YCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBpbnRlZ2VyIGNvbnN0cmFpbnQgdG8gYSBudW1iZXIgc2NoZW1hIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2ROdW1iZXJ9IG51bWJlclNjaGVtYSAtIFRoZSBiYXNlIG51bWJlciBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEuXG4gICAgICogQHJldHVybnMge3ouWm9kTnVtYmVyfSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIGludGVnZXIgdmFsaWRhdGlvbiBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5SW50ZWdlckNvbnN0cmFpbnQobnVtYmVyU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYS50eXBlICE9PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bWJlclNjaGVtYS5yZWZpbmUodmFsID0+IE51bWJlci5pc0ludGVnZXIodmFsKSwgeyBtZXNzYWdlOiAnTnVtYmVyIG11c3QgYmUgYW4gaW50ZWdlcicgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0cmluZyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSBmb3IgYSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZVN0cmluZyhzY2hlbWEpIHtcbiAgICAgICAgbGV0IHN0cmluZ1NjaGVtYSA9IHouc3RyaW5nKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdHJpbmdTY2hlbWE7XG4gICAgICAgIC8vIEFwcGx5IGFsbCBzdHJpbmcgdmFsaWRhdGlvbnNcbiAgICAgICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBmb3JtYXQtc3BlY2lmaWMgc3RyaW5nIHZhbGlkYXRpb25cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5U3RyaW5nRm9ybWF0KHN0cmluZ1NjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgb3RoZXIgdmFsaWRhdGlvbnMgaWYgZm9ybWF0IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vIG9yIGFwcGx5IHRoZW0gdG8gdGhlIGZvcm1hdHRlZCBzdHJpbmdcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlTdHJpbmdQYXR0ZXJuKHN0cmluZ1NjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlTdHJpbmdMZW5ndGgoc3RyaW5nU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseVN0cmluZ0VudW0oc3RyaW5nU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZm9ybWF0IHZhbGlkYXRpb24gdG8gYSBzdHJpbmcgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZFN0cmluZ30gc3RyaW5nU2NoZW1hIC0gVGhlIGJhc2Ugc3RyaW5nIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBmb3JtYXQgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlTdHJpbmdGb3JtYXQoc3RyaW5nU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWEuZW1haWwoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYS5kYXRldGltZSgpO1xuICAgICAgICAgICAgY2FzZSAndXJpJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hLnVybCgpO1xuICAgICAgICAgICAgY2FzZSAndXVpZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYS51dWlkKCk7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hLmRhdGUoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHBhdHRlcm4gdmFsaWRhdGlvbiB0byBhIHN0cmluZyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kU3RyaW5nfSBzdHJpbmdTY2hlbWEgLSBUaGUgYmFzZSBzdHJpbmcgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggcGF0dGVybi5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2RTdHJpbmd9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggcGF0dGVybiB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseVN0cmluZ1BhdHRlcm4oc3RyaW5nU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFzY2hlbWFbJ3BhdHRlcm4nXSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoc2NoZW1hWydwYXR0ZXJuJ10pO1xuICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hLnJlZ2V4KHJlZ2V4LCB7IG1lc3NhZ2U6IGBTdHJpbmcgbXVzdCBtYXRjaCBwYXR0ZXJuOiAke3NjaGVtYVsncGF0dGVybiddfWAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgbGVuZ3RoIGNvbnN0cmFpbnRzIHRvIGEgc3RyaW5nIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2RTdHJpbmd9IHN0cmluZ1NjaGVtYSAtIFRoZSBiYXNlIHN0cmluZyBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBsZW5ndGggY29uc3RyYWludHMuXG4gICAgICogQHJldHVybnMge3ouWm9kU3RyaW5nfSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIGxlbmd0aCB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseVN0cmluZ0xlbmd0aChzdHJpbmdTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RyaW5nU2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hWydtaW5MZW5ndGgnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEubWluKHNjaGVtYVsnbWluTGVuZ3RoJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFbJ21heExlbmd0aCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5tYXgoc2NoZW1hWydtYXhMZW5ndGgnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBlbnVtIHZhbGlkYXRpb24gdG8gYSBzdHJpbmcgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZFN0cmluZ30gc3RyaW5nU2NoZW1hIC0gVGhlIGJhc2Ugc3RyaW5nIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGVudW0uXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggZW51bSB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseVN0cmluZ0VudW0oc3RyaW5nU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEuZW51bSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgcmVmaW5lbWVudCB0byB2YWxpZGF0ZSBhZ2FpbnN0IGVudW0gdmFsdWVzXG4gICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWEucmVmaW5lKCh2YWwpID0+IHNjaGVtYS5lbnVtPy5pbmNsdWRlcyh2YWwpLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBgVmFsdWUgbXVzdCBiZSBvbmUgb2Y6ICR7c2NoZW1hLmVudW0/LmpvaW4oJywgJyl9YFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgSlNPTiBzY2hlbWEgb2YgdHlwZSBhcnJheSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBab2Qgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUFycmF5KHNjaGVtYSkge1xuICAgICAgICAvLyBIYW5kbGUgdHVwbGUgdmFsaWRhdGlvbiAoaXRlbXMgaXMgYW4gYXJyYXkpXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHR1cGxlU2NoZW1hcyA9IHNjaGVtYS5pdGVtcy5tYXAoaXRlbSA9PiB0aGlzLnBhcnNlU2NoZW1hKGl0ZW0pKTtcbiAgICAgICAgICAgIHJldHVybiB6LnVuaW9uKHR1cGxlU2NoZW1hcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHJlZ3VsYXIgYXJyYXkgc2NoZW1hXG4gICAgICAgIGNvbnN0IGl0ZW1TY2hlbWEgPSBzY2hlbWEuaXRlbXMgPyB0aGlzLnBhcnNlU2NoZW1hKHNjaGVtYS5pdGVtcykgOiB6LmFueSgpO1xuICAgICAgICBsZXQgYXJyYXlTY2hlbWEgPSB6LmFycmF5KGl0ZW1TY2hlbWEpO1xuICAgICAgICAvLyBBcHBseSBhcnJheSBjb25zdHJhaW50c1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXJyYXlTY2hlbWE7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlBcnJheUNvbnN0cmFpbnRzKGFycmF5U2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGNvbnN0cmFpbnRzIHRvIGFuIGFycmF5IHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2RBcnJheTxhbnk+fSBhcnJheVNjaGVtYSAtIFRoZSBiYXNlIGFycmF5IHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGFycmF5IGNvbnN0cmFpbnRzLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZFR5cGVBbnl9IC0gVGhlIHVwZGF0ZWQgYXJyYXkgc2NoZW1hIHdpdGggY29uc3RyYWludHMuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5QXJyYXlDb25zdHJhaW50cyhhcnJheVNjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIC8vIEhhbmRsZSBtaW5JdGVtc1xuICAgICAgICBpZiAoc2NoZW1hWydtaW5JdGVtcyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFycmF5U2NoZW1hID0gYXJyYXlTY2hlbWEubWluKHNjaGVtYVsnbWluSXRlbXMnXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG1heEl0ZW1zXG4gICAgICAgIGlmIChzY2hlbWFbJ21heEl0ZW1zJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJyYXlTY2hlbWEgPSBhcnJheVNjaGVtYS5tYXgoc2NoZW1hWydtYXhJdGVtcyddKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdW5pcXVlSXRlbXNcbiAgICAgICAgaWYgKHNjaGVtYVsndW5pcXVlSXRlbXMnXSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2NoZW1hLnJlZmluZSgoaXRlbXMpID0+IG5ldyBTZXQoaXRlbXMpLnNpemUgPT09IGl0ZW1zLmxlbmd0aCwgeyBtZXNzYWdlOiAnQXJyYXkgaXRlbXMgbXVzdCBiZSB1bmlxdWUnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheVNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIG9iamVjdCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSBmb3IgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VPYmplY3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjb25kaXRpb25hbCB2YWxpZGF0aW9uIChpZi10aGVuLWVsc2UpIGZpcnN0XG4gICAgICAgIGlmIChzY2hlbWFbJ2lmJ10gJiYgc2NoZW1hWyd0aGVuJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgc2hhcGUgb2JqZWN0IGZvciBab2RcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgLy8gUHJvY2VzcyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucHJvY2Vzc09iamVjdFByb3BlcnRpZXMoc2NoZW1hLCBzaGFwZSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgb2JqZWN0IHNjaGVtYSBhbmQgaGFuZGxlIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEsIHoub2JqZWN0KHNoYXBlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBvYmplY3QgcHJvcGVydGllcyBhbmQgYnVpbGRzIHRoZSBzaGFwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSBmb3IgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgWm9kVHlwZUFueT59IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBwb3B1bGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcHJvY2Vzc09iamVjdFByb3BlcnRpZXMoc2NoZW1hLCBzaGFwZSkge1xuICAgICAgICBjb25zdCByZXF1aXJlZCA9IG5ldyBTZXQoc2NoZW1hLnJlcXVpcmVkIHx8IFtdKTtcbiAgICAgICAgaWYgKCFzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBjb25zdCB6b2RTY2hlbWEgPSB0aGlzLnBhcnNlU2NoZW1hKHByb3BTY2hlbWEpO1xuICAgICAgICAgICAgc2hhcGVba2V5XSA9IHJlcXVpcmVkLmhhcyhrZXkpID8gem9kU2NoZW1hIDogem9kU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSBmb3IgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ei5ab2RPYmplY3Q8YW55LCBhbnk+fSBvYmplY3RTY2hlbWEgLSBUaGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gICAgICogQHJldHVybnMge3ouWm9kT2JqZWN0PGFueSwgYW55Pn0gLSBUaGUgdXBkYXRlZCBab2Qgb2JqZWN0IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcHJvY2Vzc0FkZGl0aW9uYWxQcm9wZXJ0aWVzKHNjaGVtYSwgb2JqZWN0U2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RTY2hlbWEucGFzc3Rocm91Z2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgdHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzY2hlbWEgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbFByb3BTY2hlbWEgPSB0aGlzLnBhcnNlU2NoZW1hKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0U2NoZW1hLmNhdGNoYWxsKGFkZGl0aW9uYWxQcm9wU2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RTY2hlbWEuc3RyaWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgY29uZGl0aW9uYWwgc2NoZW1hIHdpdGggaWYtdGhlbi1lbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBjb25kaXRpb25hbCB2YWxpZGF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBjb25kaXRpb25hbCBab2Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUNvbmRpdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICAvLyBDcmVhdGUgYmFzZSBvYmplY3Qgc2NoZW1hXG4gICAgICAgIGNvbnN0IHpvZE9iamVjdCA9IHRoaXMuY3JlYXRlQmFzZU9iamVjdFNjaGVtYShzY2hlbWEpO1xuICAgICAgICAvLyBFeHRyYWN0IGNvbmRpdGlvbmFsIHBhcnRzXG4gICAgICAgIGNvbnN0IGlmQ29uZGl0aW9uID0gc2NoZW1hWydpZiddO1xuICAgICAgICBjb25zdCB0aGVuU2NoZW1hID0gc2NoZW1hWyd0aGVuJ107XG4gICAgICAgIGNvbnN0IGVsc2VTY2hlbWEgPSBzY2hlbWFbJ2Vsc2UnXTtcbiAgICAgICAgLy8gQXBwbHkgY29uZGl0aW9uYWwgdmFsaWRhdGlvbiB1c2luZyBzdXBlclJlZmluZVxuICAgICAgICByZXR1cm4gem9kT2JqZWN0LnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIHRvIGRhdGEgZm9yIGNvbmRpdGlvbiBjaGVja2luZ1xuICAgICAgICAgICAgY29uc3QgZGF0YVdpdGhEZWZhdWx0cyA9IHRoaXMuYXBwbHlEZWZhdWx0VmFsdWVzKGRhdGEsIHNjaGVtYSk7XG4gICAgICAgICAgICAvLyBBcHBseSBhcHByb3ByaWF0ZSB2YWxpZGF0aW9uIGJhc2VkIG9uIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hlc0NvbmRpdGlvbihkYXRhV2l0aERlZmF1bHRzLCBpZkNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZGl0aW9uYWxTY2hlbWEoZGF0YVdpdGhEZWZhdWx0cywgdGhlblNjaGVtYSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsc2VTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZGl0aW9uYWxTY2hlbWEoZGF0YVdpdGhEZWZhdWx0cywgZWxzZVNjaGVtYSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIG9iamVjdCBzY2hlbWEgZnJvbSB0aGUgZ2l2ZW4gSlNPTiBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYS5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2RPYmplY3Q8YW55LCBhbnk+fSAtIFRoZSBiYXNlIFpvZCBvYmplY3Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVCYXNlT2JqZWN0U2NoZW1hKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICBjb25zdCByZXF1aXJlZCA9IG5ldyBTZXQoc2NoZW1hLnJlcXVpcmVkIHx8IFtdKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMgfHwge30pKSB7XG4gICAgICAgICAgICBjb25zdCB6b2RTY2hlbWEgPSB0aGlzLnBhcnNlU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgIHNoYXBlW2tleV0gPSByZXF1aXJlZC5oYXMoa2V5KSA/IHpvZFNjaGVtYSA6IHpvZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHpvZE9iamVjdCA9IHoub2JqZWN0KHNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0FkZGl0aW9uYWxQcm9wZXJ0aWVzKHNjaGVtYSwgem9kT2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBkZWZhdWx0IHZhbHVlcyBmcm9tIHNjaGVtYSBwcm9wZXJ0aWVzIHRvIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OVmFsdWV9IGRhdGEgLSBUaGUgb3JpZ2luYWwgZGF0YSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgc2NoZW1hIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0pTT05WYWx1ZX0gLSBUaGUgZGF0YSBvYmplY3Qgd2l0aCBkZWZhdWx0cyBhcHBsaWVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseURlZmF1bHRWYWx1ZXMoZGF0YSwgc2NoZW1hKSB7XG4gICAgICAgIC8vIElmIGRhdGEgaXMgbm90IGFuIG9iamVjdCBvciBpcyBudWxsLCB3ZSBjYW4ndCBhcHBseSBkZWZhdWx0c1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGRhdGEgaXMgYW4gYXJyYXksIHdlIGNhbid0IGFwcGx5IGRlZmF1bHRzIGZyb20gc2NoZW1hIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IGRhdGEgaXMgYSBKU09OT2JqZWN0XG4gICAgICAgIGNvbnN0IG9iamVjdERhdGEgPSBkYXRhO1xuICAgICAgICBjb25zdCBkYXRhV2l0aERlZmF1bHRzID0geyAuLi5vYmplY3REYXRhIH07XG4gICAgICAgIGlmICghc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhV2l0aERlZmF1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gZGF0YVdpdGhEZWZhdWx0cykgJiYgJ2RlZmF1bHQnIGluIHByb3BTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBkYXRhV2l0aERlZmF1bHRzW2tleV0gPSBwcm9wU2NoZW1hWydkZWZhdWx0J107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFXaXRoRGVmYXVsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNjaGVtYSB3aXRoIGNvbWJpbmF0b3JzIChvbmVPZiwgYW55T2YsIGFsbE9mKS5cbiAgICAgKiBEZWxlZ2F0ZXMgdG8gdGhlIGFwcHJvcHJpYXRlIGNvbWJpbmF0b3IgcGFyc2VyIGJhc2VkIG9uIHdoaWNoIGNvbWJpbmF0b3IgaXMgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggY29tYmluYXRvcnMuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUNvbWJpbmF0b3Ioc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWEub25lT2YpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT25lT2Yoc2NoZW1hLm9uZU9mKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmFueU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFueU9mKHNjaGVtYS5hbnlPZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBbGxPZihzY2hlbWEuYWxsT2YpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCBub3QgcmVhY2ggaGVyZSBpZiBzY2hlbWEgaGFzIGNvbWJpbmF0b3JzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc2NoZW1hIHR5cGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgb25lT2YgY29tYmluYXRvciBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWFbXX0gc2NoZW1hcyAtIEFycmF5IG9mIEpTT04gc2NoZW1hcyBpbiB0aGUgb25lT2YuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZU9uZU9mKHNjaGVtYXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVW5pb25Gcm9tU2NoZW1hcyhzY2hlbWFzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIGFueU9mIGNvbWJpbmF0b3Igc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hW119IHNjaGVtYXMgLSBBcnJheSBvZiBKU09OIHNjaGVtYXMgaW4gdGhlIGFueU9mLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VBbnlPZihzY2hlbWFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVuaW9uRnJvbVNjaGVtYXMoc2NoZW1hcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB1bmlvbiBmcm9tIGFuIGFycmF5IG9mIHNjaGVtYXMsIGhhbmRsaW5nIHNwZWNpYWwgY2FzZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWFbXX0gc2NoZW1hcyAtIEFycmF5IG9mIEpTT04gc2NoZW1hcyB0byBjcmVhdGUgYSB1bmlvbiBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSB1bmlvbiBab2Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVVbmlvbkZyb21TY2hlbWFzKHNjaGVtYXMpIHtcbiAgICAgICAgLy8gSGFuZGxlIGVtcHR5IGFycmF5IGNhc2VcbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gei5hbnkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgc2luZ2xlIHNjaGVtYSBjYXNlXG4gICAgICAgIGlmIChzY2hlbWFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWEoc2NoZW1hc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHN1YnNjaGVtYSBpbmRpdmlkdWFsbHlcbiAgICAgICAgY29uc3Qgem9kU2NoZW1hcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YlNjaGVtYSBvZiBzY2hlbWFzKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbnVsbCB0eXBlIHNwZWNpYWxseVxuICAgICAgICAgICAgaWYgKHN1YlNjaGVtYS50eXBlID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWFzLnB1c2goei5udWxsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgem9kU2NoZW1hcy5wdXNoKHRoaXMucGFyc2VTY2hlbWEoc3ViU2NoZW1hKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGFwcHJvcHJpYXRlIHNjaGVtYSBiYXNlZCBvbiBudW1iZXIgb2YgdmFsaWQgc2NoZW1hc1xuICAgICAgICBpZiAoem9kU2NoZW1hcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHoudW5pb24oem9kU2NoZW1hcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoem9kU2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB6b2RTY2hlbWFzWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIGlmIG5vIHZhbGlkIHNjaGVtYXMgd2VyZSBjcmVhdGVkXG4gICAgICAgIHJldHVybiB6LmFueSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gYWxsT2YgY29tYmluYXRvciBzY2hlbWEgYnkgbWVyZ2luZyBhbGwgc2NoZW1hcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYVtdfSBzY2hlbWFzIC0gQXJyYXkgb2YgSlNPTiBzY2hlbWFzIGluIHRoZSBhbGxPZi5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQWxsT2Yoc2NoZW1hcykge1xuICAgICAgICAvLyBIYW5kbGUgZW1wdHkgYXJyYXkgY2FzZVxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB6LmFueSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBzaW5nbGUgc2NoZW1hIGNhc2VcbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYShzY2hlbWFzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZXJnZSBhbGwgc2NoZW1hcyB0b2dldGhlclxuICAgICAgICBjb25zdCBtZXJnZWRTY2hlbWEgPSBzY2hlbWFzLnJlZHVjZSgoYWNjLCBjdXJyZW50U2NoZW1hKSA9PiB0aGlzLm1lcmdlU2NoZW1hcyhhY2MsIGN1cnJlbnRTY2hlbWEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWEobWVyZ2VkU2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHR3byBKU09OIHNjaGVtYXMgdG9nZXRoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IGJhc2VTY2hlbWEgLSBUaGUgYmFzZSBKU09OIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IGFkZFNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB0byBhZGQuXG4gICAgICogQHJldHVybnMge0pTT05TY2hlbWF9IC0gVGhlIG1lcmdlZCBKU09OIHNjaGVtYVxuICAgICAqL1xuICAgIHN0YXRpYyBtZXJnZVNjaGVtYXMoYmFzZVNjaGVtYSwgYWRkU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4uYmFzZVNjaGVtYSwgLi4uYWRkU2NoZW1hIH07XG4gICAgICAgIGlmIChiYXNlU2NoZW1hLnByb3BlcnRpZXMgJiYgYWRkU2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFByb3BlcnRpZXMgPSB7IC4uLmJhc2VTY2hlbWEucHJvcGVydGllcywgLi4uYWRkU2NoZW1hLnByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgIG1lcmdlZC5wcm9wZXJ0aWVzID0gbWVyZ2VkUHJvcGVydGllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVNjaGVtYS5yZXF1aXJlZCAmJiBhZGRTY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFJlcXVpcmVkID0gWy4uLm5ldyBTZXQoWy4uLmJhc2VTY2hlbWEucmVxdWlyZWQsIC4uLmFkZFNjaGVtYS5yZXF1aXJlZF0pXTtcbiAgICAgICAgICAgIG1lcmdlZC5yZXF1aXJlZCA9IG1lcmdlZFJlcXVpcmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvVHlwZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL0BkbWl0cnlyZWNoa2luL2pzb24tc2NoZW1hLXRvLXpvZC9kaXN0L1R5cGUuanM/MmIxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONSchemaToZod: () => (/* reexport safe */ _JSONSchemaToZod_js__WEBPACK_IMPORTED_MODULE_0__.JSONSchemaToZod)\n/* harmony export */ });\n/* harmony import */ var _JSONSchemaToZod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JSONSchemaToZod.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js\");\n/* harmony import */ var _Type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL0BkbWl0cnlyZWNoa2luL2pzb24tc2NoZW1hLXRvLXpvZC9kaXN0L2luZGV4LmpzP2ZhOWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9KU09OU2NoZW1hVG9ab2QuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9UeXBlLmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js\n");

/***/ })

};
;