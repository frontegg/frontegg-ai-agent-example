/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/classes/comparator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/classes/comparator.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/parse-options.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/re.js\")\nconst cmp = __webpack_require__(/*! ../functions/cmp */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/cmp.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ./range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9jb21wYXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsS0FBSztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsK0dBQTJCO0FBQ3hELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx5RkFBZ0I7QUFDbEQsWUFBWSxtQkFBTyxDQUFDLDZGQUFrQjtBQUN0QyxjQUFjLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzRkFBVTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsb0ZBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcz82MTQzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEFOWSA9IFN5bWJvbCgnU2VtVmVyIEFOWScpXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgQ29tcGFyYXRvciB7XG4gIHN0YXRpYyBnZXQgQU5ZICgpIHtcbiAgICByZXR1cm4gQU5ZXG4gIH1cblxuICBjb25zdHJ1Y3RvciAoY29tcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICByZXR1cm4gY29tcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcCA9IGNvbXAudmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wID0gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKCcgJylcbiAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgdGhpcy52YWx1ZSA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvblxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wJywgdGhpcylcbiAgfVxuXG4gIHBhcnNlIChjb21wKSB7XG4gICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5sb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCBtID0gY29tcC5tYXRjaChyKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7Y29tcH1gKVxuICAgIH1cblxuICAgIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJydcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICB0aGlzLm9wZXJhdG9yID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgICBpZiAoIW1bMl0pIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gQU5ZXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cblxuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbnRlcnNlY3RzIChjb21wLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpLnRlc3QodGhpcy52YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcilcbiAgICB9XG5cbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzIHdoZXJlIG5vdGhpbmcgY2FuIHBvc3NpYmx5IGJlIGxvd2VyXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICAgICh0aGlzLnZhbHVlID09PSAnPDAuMC4wLTAnIHx8IGNvbXAudmFsdWUgPT09ICc8MC4wLjAtMCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSB8fCBjb21wLnZhbHVlLnN0YXJ0c1dpdGgoJzwwLjAuMCcpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gU2FtZSBkaXJlY3Rpb24gaW5jcmVhc2luZyAoPiBvciA+PSlcbiAgICBpZiAodGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGRlY3JlYXNpbmcgKDwgb3IgPD0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBzYW1lIFNlbVZlciBhbmQgYm90aCBzaWRlcyBhcmUgaW5jbHVzaXZlICg8PSBvciA+PSlcbiAgICBpZiAoXG4gICAgICAodGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbikgJiZcbiAgICAgIHRoaXMub3BlcmF0b3IuaW5jbHVkZXMoJz0nKSAmJiBjb21wLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIG9wcG9zaXRlIGRpcmVjdGlvbnMgbGVzcyB0aGFuXG4gICAgaWYgKGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgIHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGdyZWF0ZXIgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wYXJhdG9yXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL3JhbmdlJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/classes/comparator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/classes/range.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = __webpack_require__(/*! ../internal/lrucache */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/lrucache.js\")\nconst cache = new LRU()\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/parse-options.js\")\nconst Comparator = __webpack_require__(/*! ./comparator */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/comparator.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = __webpack_require__(/*! ../internal/re */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/re.js\")\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(/*! ../internal/constants */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/constants.js\")\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsU0FBUztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFDSixnQkFBZ0IsR0FBRyxHQUFHLEdBQUcsSUFBSSxrQkFBa0I7QUFDL0MsSUFBSTtBQUNKLGdCQUFnQixLQUFLO0FBQ3JCLElBQUk7QUFDSixnQkFBZ0IsS0FBSyxFQUFFLGtCQUFrQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWEsUUFBUTtBQUNyQixJQUFJO0FBQ0osYUFBYSxHQUFHLEdBQUcsUUFBUTtBQUMzQixJQUFJO0FBQ0osY0FBYyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJO0FBQ3BDLElBQUk7QUFDSixhQUFhLEdBQUcsR0FBRyxHQUFHLEdBQUcsUUFBUTtBQUNqQyxJQUFJO0FBQ0osY0FBYyxHQUFHO0FBQ2pCOztBQUVBLFlBQVksTUFBTSxFQUFFLEdBQUc7QUFDdkI7O0FBRUE7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzP2QzMjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU1BBQ0VfQ0hBUkFDVEVSUyA9IC9cXHMrL2dcblxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdHRlZCA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIC8vIEZpcnN0IHJlZHVjZSBhbGwgd2hpdGVzcGFjZSBhcyBtdWNoIGFzIHBvc3NpYmxlIHNvIHdlIGRvIG5vdCBoYXZlIHRvIHJlbHlcbiAgICAvLyBvbiBwb3RlbnRpYWxseSBzbG93IHJlZ2V4ZXMgbGlrZSBcXHMqLiBUaGlzIGlzIHRoZW4gc3RvcmVkIGFuZCB1c2VkIGZvclxuICAgIC8vIGZ1dHVyZSBlcnJvciBtZXNzYWdlcyBhcyB3ZWxsLlxuICAgIHRoaXMucmF3ID0gcmFuZ2UudHJpbSgpLnJlcGxhY2UoU1BBQ0VfQ0hBUkFDVEVSUywgJyAnKVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IG9uIHx8XG4gICAgdGhpcy5zZXQgPSB0aGlzLnJhd1xuICAgICAgLnNwbGl0KCd8fCcpXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAociA9PiB0aGlzLnBhcnNlUmFuZ2Uoci50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpXG5cbiAgICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7dGhpcy5yYXd9YClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSBub3QgdGhlIG51bGwgc2V0LCB0aHJvdyBvdXQgbnVsbCBzZXRzLlxuICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBrZWVwIHRoZSBmaXJzdCBvbmUsIGluIGNhc2UgdGhleSdyZSBhbGwgbnVsbCBzZXRzXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2V0WzBdXG4gICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmZpbHRlcihjID0+ICFpc051bGxTZXQoY1swXSkpXG4gICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlICosIHRoZW4gdGhlIHJhbmdlIGlzIGp1c3QgKlxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gW2NdXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0dGVkID0gdW5kZWZpbmVkXG4gIH1cblxuICBnZXQgcmFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmZvcm1hdHRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZvcm1hdHRlZCA9ICcnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkICs9ICd8fCdcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMuc2V0W2ldXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY29tcHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAoayA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkICs9ICcgJ1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZvcm1hdHRlZCArPSBjb21wc1trXS50b1N0cmluZygpLnRyaW0oKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZFxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICBwYXJzZVJhbmdlIChyYW5nZSkge1xuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID1cbiAgICAgICh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UpIHxcbiAgICAgICh0aGlzLm9wdGlvbnMubG9vc2UgJiYgRkxBR19MT09TRSlcbiAgICBjb25zdCBtZW1vS2V5ID0gbWVtb09wdHMgKyAnOicgKyByYW5nZVxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KVxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRcbiAgICB9XG5cbiAgICBjb25zdCBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSlcbiAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcblxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ3RpbGRlIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NhcmV0IHRyaW0nLCByYW5nZSlcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGxldCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICBpZiAobG9vc2UpIHtcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICByYW5nZUxpc3QgPSByYW5nZUxpc3QuZmlsdGVyKGNvbXAgPT4ge1xuICAgICAgICBkZWJ1ZygnbG9vc2UgaW52YWxpZCBmaWx0ZXInLCBjb21wLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmVbdC5DT01QQVJBVE9STE9PU0VdKVxuICAgICAgfSlcbiAgICB9XG4gICAgZGVidWcoJ3JhbmdlIGxpc3QnLCByYW5nZUxpc3QpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlTGlzdC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wYXJhdG9ycykge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSkge1xuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICB9XG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpIHtcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVxuXG5jb25zdCBMUlUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9scnVjYWNoZScpXG5jb25zdCBjYWNoZSA9IG5ldyBMUlUoKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHNhZmVSZTogcmUsXG4gIHQsXG4gIGNvbXBhcmF0b3JUcmltUmVwbGFjZSxcbiAgdGlsZGVUcmltUmVwbGFjZSxcbiAgY2FyZXRUcmltUmVwbGFjZSxcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCB7IEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFLCBGTEFHX0xPT1NFIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjAuMC4xIC0tPiA+PTAuMC4xIDwwLjEuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucykpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlVGlsZGUgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuVElMREVMT09TRV0gOiByZVt0LlRJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wIDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAgPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMC0wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4wLjAuMSAtLT4gPj0wLjAuMSA8MC4wLjItMFxuLy8gXjAuMS4wIC0tPiA+PTAuMS4wIDwwLjIuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucykpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgLm1hcCgoYykgPT4gcmVwbGFjZVhSYW5nZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICBwciA9ICctMCdcbiAgICAgIH1cblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuLy8gVE9ETyBidWlsZD9cbmNvbnN0IGh5cGhlblJlcGxhY2UgPSBpbmNQciA9PiAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiBgJHtmcm9tfSAke3RvfWAudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/classes/semver.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! ../internal/debug */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/debug.js\")\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/constants.js\")\nconst { safeRe: re, safeSrc: src, t } = __webpack_require__(/*! ../internal/re */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/re.js\")\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/parse-options.js\")\nconst { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/identifiers.js\")\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n        version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    if (release.startsWith('pre')) {\n      if (!identifier && identifierBase === false) {\n        throw new Error('invalid increment argument: identifier is empty')\n      }\n      // Avoid an invalid semver results\n      if (identifier) {\n        const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`)\n        const match = `-${identifier}`.match(r)\n        if (!match || match[1] !== identifier) {\n          throw new Error(`invalid identifier: ${identifier}`)\n        }\n      }\n    }\n\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'release':\n        if (this.prerelease.length === 0) {\n          throw new Error(`version ${this.raw} is not a prerelease`)\n        }\n        this.prerelease.length = 0\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLCtGQUFtQjtBQUN6QyxRQUFRLCtCQUErQixFQUFFLG1CQUFPLENBQUMsdUdBQXVCO0FBQ3hFLFFBQVEsOEJBQThCLEVBQUUsbUJBQU8sQ0FBQyx5RkFBZ0I7O0FBRWhFLHFCQUFxQixtQkFBTyxDQUFDLCtHQUEyQjtBQUN4RCxRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsMkdBQXlCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBFQUEwRSxlQUFlO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDN0Q7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnRUFBZ0U7QUFDakcsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcz9jODEwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgeyBNQVhfTEVOR1RILCBNQVhfU0FGRV9JTlRFR0VSIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCBzYWZlU3JjOiBzcmMsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2ZXJzaW9uLiBNdXN0IGJlIGEgc3RyaW5nLiBHb3QgdHlwZSBcIiR7dHlwZW9mIHZlcnNpb259XCIuYClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ2J1aWxkIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuICBpbmMgKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSB7XG4gICAgaWYgKHJlbGVhc2Uuc3RhcnRzV2l0aCgncHJlJykpIHtcbiAgICAgIGlmICghaWRlbnRpZmllciAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBpcyBlbXB0eScpXG4gICAgICB9XG4gICAgICAvLyBBdm9pZCBhbiBpbnZhbGlkIHNlbXZlciByZXN1bHRzXG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCByID0gbmV3IFJlZ0V4cChgXiR7dGhpcy5vcHRpb25zLmxvb3NlID8gc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSA6IHNyY1t0LlBSRVJFTEVBU0VdfSRgKVxuICAgICAgICBjb25zdCBtYXRjaCA9IGAtJHtpZGVudGlmaWVyfWAubWF0Y2gocilcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSAhPT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpZGVudGlmaWVyOiAke2lkZW50aWZpZXJ9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgICAvLyBwcmVwYXRjaC5cbiAgICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmVyc2lvbiAke3RoaXMucmF3fSBpcyBub3QgYSBwcmVyZWxlYXNlYClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6IHtcbiAgICAgICAgY29uc3QgYmFzZSA9IE51bWJlcihpZGVudGlmaWVyQmFzZSkgPyAxIDogMFxuXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2Jhc2VdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIgPT09IHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJykgJiYgaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goYmFzZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgbGV0IHByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgYmFzZV1cbiAgICAgICAgICBpZiAoaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcmVyZWxlYXNlID0gW2lkZW50aWZpZXJdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21wYXJlSWRlbnRpZmllcnModGhpcy5wcmVyZWxlYXNlWzBdLCBpZGVudGlmaWVyKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5yYXcgPSB0aGlzLmZvcm1hdCgpXG4gICAgaWYgKHRoaXMuYnVpbGQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhdyArPSBgKyR7dGhpcy5idWlsZC5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/clean.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/clean.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js\")\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NsZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxzRkFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanM/NWQ0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/clean.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/cmp.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/cmp.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const eq = __webpack_require__(/*! ./eq */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./neq */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/neq.js\")\nconst gt = __webpack_require__(/*! ./gt */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/gt.js\")\nconst gte = __webpack_require__(/*! ./gte */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/gte.js\")\nconst lt = __webpack_require__(/*! ./lt */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ./lte */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/lte.js\")\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NtcC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsZ0ZBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLGtGQUFPO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxnRkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsa0ZBQU87QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGdGQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxrRkFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanM/M2Y5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/cmp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/coerce.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/coerce.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst parse = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/re.js\")\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvZXJjZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsK0ZBQW1CO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxzRkFBUztBQUMvQixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMseUZBQWdCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsU0FBUztBQUMxRSw0REFBNEQsU0FBUzs7QUFFckUsa0JBQWtCLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNO0FBQy9EO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanM/Zjg4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRUZVTExdIDogcmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy8gV2l0aCBpbmNsdWRlUHJlcmVsZWFzZSBvcHRpb24gc2V0LCAnMS4yLjMuNC1yYycgd2FudHMgdG8gY29lcmNlICcyLjMuNC1yYycsIG5vdCAnMi4zLjQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBjb25zdCBjb2VyY2VSdGxSZWdleCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRVJUTEZVTExdIDogcmVbdC5DT0VSQ0VSVExdXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSBjb2VyY2VSdGxSZWdleC5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICBjb2VyY2VSdGxSZWdleC5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgY29lcmNlUnRsUmVnZXgubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtYWpvciA9IG1hdGNoWzJdXG4gIGNvbnN0IG1pbm9yID0gbWF0Y2hbM10gfHwgJzAnXG4gIGNvbnN0IHBhdGNoID0gbWF0Y2hbNF0gfHwgJzAnXG4gIGNvbnN0IHByZXJlbGVhc2UgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIG1hdGNoWzVdID8gYC0ke21hdGNoWzVdfWAgOiAnJ1xuICBjb25zdCBidWlsZCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgbWF0Y2hbNl0gPyBgKyR7bWF0Y2hbNl19YCA6ICcnXG5cbiAgcmV0dXJuIHBhcnNlKGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSR7cHJlcmVsZWFzZX0ke2J1aWxkfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/coerce.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-build.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/compare-build.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLCtGQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzP2FhN2IiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-build.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-loose.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/compare-loose.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsMEZBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanM/YzdiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-loose.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/compare.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLCtGQUFtQjtBQUMxQztBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qcz9kMGM4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/diff.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/diff.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js\")\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // If the main part has no difference\n    if (lowVersion.compareMain(highVersion) === 0) {\n      if (lowVersion.minor && !lowVersion.patch) {\n        return 'minor'\n      }\n      return 'patch'\n    }\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHlGQUFZOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanM/NzlmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xLCBudWxsLCB0cnVlKVxuICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yLCBudWxsLCB0cnVlKVxuICBjb25zdCBjb21wYXJpc29uID0gdjEuY29tcGFyZSh2MilcblxuICBpZiAoY29tcGFyaXNvbiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB2MUhpZ2hlciA9IGNvbXBhcmlzb24gPiAwXG4gIGNvbnN0IGhpZ2hWZXJzaW9uID0gdjFIaWdoZXIgPyB2MSA6IHYyXG4gIGNvbnN0IGxvd1ZlcnNpb24gPSB2MUhpZ2hlciA/IHYyIDogdjFcbiAgY29uc3QgaGlnaEhhc1ByZSA9ICEhaGlnaFZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGhcbiAgY29uc3QgbG93SGFzUHJlID0gISFsb3dWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG5cbiAgaWYgKGxvd0hhc1ByZSAmJiAhaGlnaEhhc1ByZSkge1xuICAgIC8vIEdvaW5nIGZyb20gcHJlcmVsZWFzZSAtPiBubyBwcmVyZWxlYXNlIHJlcXVpcmVzIHNvbWUgc3BlY2lhbCBjYXNpbmdcblxuICAgIC8vIElmIHRoZSBsb3cgdmVyc2lvbiBoYXMgb25seSBhIG1ham9yLCB0aGVuIGl0IHdpbGwgYWx3YXlzIGJlIGEgbWFqb3JcbiAgICAvLyBTb21lIGV4YW1wbGVzOlxuICAgIC8vIDEuMC4wLTEgLT4gMS4wLjBcbiAgICAvLyAxLjAuMC0xIC0+IDEuMS4xXG4gICAgLy8gMS4wLjAtMSAtPiAyLjAuMFxuICAgIGlmICghbG93VmVyc2lvbi5wYXRjaCAmJiAhbG93VmVyc2lvbi5taW5vcikge1xuICAgICAgcmV0dXJuICdtYWpvcidcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbWFpbiBwYXJ0IGhhcyBubyBkaWZmZXJlbmNlXG4gICAgaWYgKGxvd1ZlcnNpb24uY29tcGFyZU1haW4oaGlnaFZlcnNpb24pID09PSAwKSB7XG4gICAgICBpZiAobG93VmVyc2lvbi5taW5vciAmJiAhbG93VmVyc2lvbi5wYXRjaCkge1xuICAgICAgICByZXR1cm4gJ21pbm9yJ1xuICAgICAgfVxuICAgICAgcmV0dXJuICdwYXRjaCdcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBoaWdoIGFuZCBsb3cgYXJlIHByZWxlYXNlc1xuICByZXR1cm4gJ3ByZXJlbGVhc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/diff.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/eq.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/eq.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2VxLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9lcS5qcz85YzRkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/eq.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/gt.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/gt.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcz9mMTgwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/gt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/gte.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/gte.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzPzY3MzMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/gte.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/inc.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/inc.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsK0ZBQW1COztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcz9iODEyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgaW5jID0gKHZlcnNpb24sIHJlbGVhc2UsIG9wdGlvbnMsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXJCYXNlID0gaWRlbnRpZmllclxuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcihcbiAgICAgIHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIgPyB2ZXJzaW9uLnZlcnNpb24gOiB2ZXJzaW9uLFxuICAgICAgb3B0aW9uc1xuICAgICkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/inc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/lt.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/lt.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdC5qcz8wYjI3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/lt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/lte.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/lte.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzP2IyODUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/lte.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/major.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/major.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21ham9yLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21ham9yLmpzPzZiNDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/major.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/minor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/minor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21pbm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21pbm9yLmpzPzQwNjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/minor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/neq.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/neq.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzPzUzZGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/neq.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/parse.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzPzM1MzIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucywgdGhyb3dFcnJvcnMgPSBmYWxzZSkgPT4ge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmICghdGhyb3dFcnJvcnMpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHRocm93IGVyXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/patch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/patch.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzP2QxOTciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGF0Y2ggPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/patch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/prerelease.js":
/*!****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/prerelease.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js\")\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ByZXJlbGVhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHNGQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzPzIxMTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/prerelease.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/rcompare.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/rcompare.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yY29tcGFyZS5qcz8zNjA1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/rcompare.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/rsort.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/rsort.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-build.js\")\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jzb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLHNHQUFpQjtBQUM5QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanM/YWZiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/rsort.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/satisfies.js":
/*!***************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/satisfies.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsNkZBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzPzM0OGQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/satisfies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/sort.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/sort.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-build.js\")\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsc0dBQWlCO0FBQzlDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzP2UzOWYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/sort.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/functions/valid.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/functions/valid.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js\")\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxzRkFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvdmFsaWQuanM/MDQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgdmFsaWQgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/functions/valid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(/*! ./internal/re */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/re.js\")\nconst constants = __webpack_require__(/*! ./internal/constants */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/constants.js\")\nconst SemVer = __webpack_require__(/*! ./classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst identifiers = __webpack_require__(/*! ./internal/identifiers */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/identifiers.js\")\nconst parse = __webpack_require__(/*! ./functions/parse */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/parse.js\")\nconst valid = __webpack_require__(/*! ./functions/valid */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/valid.js\")\nconst clean = __webpack_require__(/*! ./functions/clean */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/clean.js\")\nconst inc = __webpack_require__(/*! ./functions/inc */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/inc.js\")\nconst diff = __webpack_require__(/*! ./functions/diff */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/diff.js\")\nconst major = __webpack_require__(/*! ./functions/major */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/major.js\")\nconst minor = __webpack_require__(/*! ./functions/minor */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/minor.js\")\nconst patch = __webpack_require__(/*! ./functions/patch */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/patch.js\")\nconst prerelease = __webpack_require__(/*! ./functions/prerelease */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/prerelease.js\")\nconst compare = __webpack_require__(/*! ./functions/compare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nconst rcompare = __webpack_require__(/*! ./functions/rcompare */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/rcompare.js\")\nconst compareLoose = __webpack_require__(/*! ./functions/compare-loose */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-loose.js\")\nconst compareBuild = __webpack_require__(/*! ./functions/compare-build */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare-build.js\")\nconst sort = __webpack_require__(/*! ./functions/sort */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/sort.js\")\nconst rsort = __webpack_require__(/*! ./functions/rsort */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/rsort.js\")\nconst gt = __webpack_require__(/*! ./functions/gt */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ./functions/lt */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/lt.js\")\nconst eq = __webpack_require__(/*! ./functions/eq */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./functions/neq */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/neq.js\")\nconst gte = __webpack_require__(/*! ./functions/gte */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/gte.js\")\nconst lte = __webpack_require__(/*! ./functions/lte */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/lte.js\")\nconst cmp = __webpack_require__(/*! ./functions/cmp */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/cmp.js\")\nconst coerce = __webpack_require__(/*! ./functions/coerce */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/coerce.js\")\nconst Comparator = __webpack_require__(/*! ./classes/comparator */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/comparator.js\")\nconst Range = __webpack_require__(/*! ./classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ./functions/satisfies */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/satisfies.js\")\nconst toComparators = __webpack_require__(/*! ./ranges/to-comparators */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/to-comparators.js\")\nconst maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/max-satisfying.js\")\nconst minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/min-satisfying.js\")\nconst minVersion = __webpack_require__(/*! ./ranges/min-version */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/min-version.js\")\nconst validRange = __webpack_require__(/*! ./ranges/valid */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/valid.js\")\nconst outside = __webpack_require__(/*! ./ranges/outside */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/outside.js\")\nconst gtr = __webpack_require__(/*! ./ranges/gtr */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/gtr.js\")\nconst ltr = __webpack_require__(/*! ./ranges/ltr */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/ltr.js\")\nconst intersects = __webpack_require__(/*! ./ranges/intersects */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/intersects.js\")\nconst simplifyRange = __webpack_require__(/*! ./ranges/simplify */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/simplify.js\")\nconst subset = __webpack_require__(/*! ./ranges/subset */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/subset.js\")\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBZTtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxzR0FBc0I7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLDhGQUFrQjtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQywwR0FBd0I7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLGdHQUFtQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsZ0dBQW1CO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDekMsWUFBWSxtQkFBTyxDQUFDLDRGQUFpQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsOEZBQWtCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDekMsY0FBYyxtQkFBTyxDQUFDLGdHQUFtQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsZ0dBQW1CO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDBHQUF3QjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxvR0FBcUI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsc0dBQXNCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLGdIQUEyQjtBQUN4RCxxQkFBcUIsbUJBQU8sQ0FBQyxnSEFBMkI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLDhGQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMsZ0dBQW1CO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQywwRkFBZ0I7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLDBGQUFnQjtBQUNuQyxXQUFXLG1CQUFPLENBQUMsMEZBQWdCO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyw0RkFBaUI7QUFDckMsWUFBWSxtQkFBTyxDQUFDLDRGQUFpQjtBQUNyQyxZQUFZLG1CQUFPLENBQUMsNEZBQWlCO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyw0RkFBaUI7QUFDckMsZUFBZSxtQkFBTyxDQUFDLGtHQUFvQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxzR0FBc0I7QUFDakQsY0FBYyxtQkFBTyxDQUFDLDRGQUFpQjtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyx3R0FBdUI7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsNEdBQXlCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDRHQUF5QjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyw0R0FBeUI7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsc0dBQXNCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDBGQUFnQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBa0I7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLHNGQUFjO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyxzRkFBYztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBcUI7QUFDaEQsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQW1CO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyw0RkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanM/MWY2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBpZGVudGlmaWVycyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpXG5jb25zdCB2YWxpZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJylcbmNvbnN0IGNsZWFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKVxuY29uc3QgaW5jID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJylcbmNvbnN0IGRpZmYgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJylcbmNvbnN0IG1ham9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKVxuY29uc3QgbWlub3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpXG5jb25zdCBwYXRjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJylcbmNvbnN0IHByZXJlbGVhc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JylcbmNvbnN0IHJzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGNvZXJjZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblZlcnNpb24gPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpXG5jb25zdCB2YWxpZFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKVxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKVxuY29uc3QgZ3RyID0gcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJylcbmNvbnN0IGx0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpXG5jb25zdCBpbnRlcnNlY3RzID0gcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpXG5jb25zdCBzaW1wbGlmeVJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKVxuY29uc3Qgc3Vic2V0ID0gcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0Jylcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZSxcbiAgdmFsaWQsXG4gIGNsZWFuLFxuICBpbmMsXG4gIGRpZmYsXG4gIG1ham9yLFxuICBtaW5vcixcbiAgcGF0Y2gsXG4gIHByZXJlbGVhc2UsXG4gIGNvbXBhcmUsXG4gIHJjb21wYXJlLFxuICBjb21wYXJlTG9vc2UsXG4gIGNvbXBhcmVCdWlsZCxcbiAgc29ydCxcbiAgcnNvcnQsXG4gIGd0LFxuICBsdCxcbiAgZXEsXG4gIG5lcSxcbiAgZ3RlLFxuICBsdGUsXG4gIGNtcCxcbiAgY29lcmNlLFxuICBDb21wYXJhdG9yLFxuICBSYW5nZSxcbiAgc2F0aXNmaWVzLFxuICB0b0NvbXBhcmF0b3JzLFxuICBtYXhTYXRpc2Z5aW5nLFxuICBtaW5TYXRpc2Z5aW5nLFxuICBtaW5WZXJzaW9uLFxuICB2YWxpZFJhbmdlLFxuICBvdXRzaWRlLFxuICBndHIsXG4gIGx0cixcbiAgaW50ZXJzZWN0cyxcbiAgc2ltcGxpZnlSYW5nZSxcbiAgc3Vic2V0LFxuICBTZW1WZXIsXG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogY29uc3RhbnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFJFTEVBU0VfVFlQRVM6IGNvbnN0YW50cy5SRUxFQVNFX1RZUEVTLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMucmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/internal/constants.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/internal/constants.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9jb25zdGFudHMuanM/MjAzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbi8vIE1heCBzYWZlIGxlbmd0aCBmb3IgYSBidWlsZCBpZGVudGlmaWVyLiBUaGUgbWF4IGxlbmd0aCBtaW51cyA2IGNoYXJhY3RlcnMgZm9yXG4vLyB0aGUgc2hvcnRlc3QgdmVyc2lvbiB3aXRoIGEgYnVpbGQgMC4wLjArQlVJTEQuXG5jb25zdCBNQVhfU0FGRV9CVUlMRF9MRU5HVEggPSBNQVhfTEVOR1RIIC0gNlxuXG5jb25zdCBSRUxFQVNFX1RZUEVTID0gW1xuICAnbWFqb3InLFxuICAncHJlbWFqb3InLFxuICAnbWlub3InLFxuICAncHJlbWlub3InLFxuICAncGF0Y2gnLFxuICAncHJlcGF0Y2gnLFxuICAncHJlcmVsZWFzZScsXG5dXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxuICBNQVhfU0FGRV9CVUlMRF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIFJFTEVBU0VfVFlQRVMsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFOiAwYjAwMSxcbiAgRkxBR19MT09TRTogMGIwMTAsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/internal/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/internal/debug.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/internal/debug.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzPzU4MTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/internal/debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/internal/identifiers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/internal/identifiers.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcz81MGYzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG51bWVyaWMgPSAvXlswLTldKyQvXG5jb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIGNvbnN0IGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/internal/identifiers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/internal/lrucache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/internal/lrucache.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("class LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvbHJ1Y2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9scnVjYWNoZS5qcz80NDhhIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWF4ID0gMTAwMFxuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KGtleSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGtleSBmcm9tIHRoZSBtYXAgYW5kIGFkZCBpdCB0byB0aGUgZW5kXG4gICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cblxuICBkZWxldGUgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuZGVsZXRlKGtleSlcblxuICAgIGlmICghZGVsZXRlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiBjYWNoZSBpcyBmdWxsLCBkZWxldGUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbVxuICAgICAgaWYgKHRoaXMubWFwLnNpemUgPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLm1hcC5rZXlzKCkubmV4dCgpLnZhbHVlXG4gICAgICAgIHRoaXMuZGVsZXRlKGZpcnN0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/internal/lrucache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/internal/parse-options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/internal/parse-options.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcGFyc2Utb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzPzNmZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dFxuY29uc3QgbG9vc2VPcHRpb24gPSBPYmplY3QuZnJlZXplKHsgbG9vc2U6IHRydWUgfSlcbmNvbnN0IGVtcHR5T3B0cyA9IE9iamVjdC5mcmVlemUoeyB9KVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBlbXB0eU9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbG9vc2VPcHRpb25cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/internal/parse-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/internal/re.js":
/*!*******************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/internal/re.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/constants.js\")\nconst debug = __webpack_require__(/*! ./debug */ \"(rsc)/./node_modules/langsmith/node_modules/semver/internal/debug.js\")\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst safeSrc = exports.safeSrc = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  safeSrc[index] = safe\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2RkFBYTtBQUN6QixjQUFjLG1CQUFPLENBQUMscUZBQVM7QUFDL0I7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsZUFBZSxjQUFjO0FBQzdCLFlBQVksV0FBVztBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQixVQUFVLFNBQVM7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSxZQUFZLE9BQU8sSUFBSSxLQUFLO0FBQ2xELGdCQUFnQixNQUFNLFlBQVksT0FBTyxJQUFJLEtBQUs7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsaUJBQWlCOztBQUVyRTtBQUNBOztBQUVBLCtCQUErQix5QkFBeUI7QUFDeEQsdUJBQXVCLHlCQUF5QjtBQUNoRCx1QkFBdUIseUJBQXlCOztBQUVoRCxvQ0FBb0MsOEJBQThCO0FBQ2xFLDRCQUE0Qiw4QkFBOEI7QUFDMUQsNEJBQTRCLDhCQUE4Qjs7QUFFMUQ7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUMsQ0FBQyxHQUFHLDRCQUE0Qjs7QUFFaEMsK0NBQStDO0FBQy9DLENBQUMsR0FBRyw0QkFBNEI7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEMsQ0FBQyxRQUFRLDRCQUE0Qjs7QUFFckMsd0NBQXdDO0FBQ3hDLENBQUMsUUFBUSxpQ0FBaUM7O0FBRTFDO0FBQ0E7O0FBRUEsa0NBQWtDLGlCQUFpQjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQixDQUFDLFFBQVEsdUJBQXVCOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLENBQUMsRUFBRSxrQkFBa0I7QUFDckIsZUFBZTs7QUFFZix3QkFBd0IsaUJBQWlCOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsQ0FBQyxFQUFFLHVCQUF1QjtBQUMxQixlQUFlOztBQUVmLHlCQUF5QixrQkFBa0I7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4QkFBOEI7QUFDdEUsbUNBQW1DLHlCQUF5Qjs7QUFFNUQsdUNBQXVDLHdCQUF3QjtBQUMvRCw2QkFBNkIsd0JBQXdCO0FBQ3JELDZCQUE2Qix3QkFBd0I7QUFDckQseUJBQXlCLGtCQUFrQjtBQUMzQyxrQ0FBa0M7QUFDbEM7O0FBRUEsNENBQTRDLDZCQUE2QjtBQUN6RSxrQ0FBa0MsNkJBQTZCO0FBQy9ELGtDQUFrQyw2QkFBNkI7QUFDL0QsOEJBQThCLHVCQUF1QjtBQUNyRCx1Q0FBdUM7QUFDdkM7O0FBRUEsMEJBQTBCLFlBQVksTUFBTSxtQkFBbUI7QUFDL0QsK0JBQStCLFlBQVksTUFBTSx3QkFBd0I7O0FBRXpFO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsb0JBQW9CLElBQUksRUFBRSwyQkFBMkI7QUFDckQsMEJBQTBCLElBQUksMkJBQTJCO0FBQ3pELDBCQUEwQixJQUFJLDJCQUEyQjtBQUN6RCx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxpQkFBaUI7QUFDbkQsd0JBQXdCOztBQUV4Qix5QkFBeUIsaUJBQWlCLEVBQUUsbUJBQW1CO0FBQy9ELDhCQUE4QixpQkFBaUIsRUFBRSx3QkFBd0I7O0FBRXpFO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELHdCQUF3Qjs7QUFFeEIseUJBQXlCLGlCQUFpQixFQUFFLG1CQUFtQjtBQUMvRCw4QkFBOEIsaUJBQWlCLEVBQUUsd0JBQXdCOztBQUV6RTtBQUNBLG1DQUFtQyxZQUFZLE9BQU8sa0JBQWtCO0FBQ3hFLDhCQUE4QixZQUFZLE9BQU8saUJBQWlCOztBQUVsRTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLENBQUMsT0FBTyxrQkFBa0IsR0FBRyxtQkFBbUI7QUFDaEQsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDOztBQUVBLHlDQUF5Qyx3QkFBd0I7QUFDakU7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzPzY3NWEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge1xuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxuICBNQVhfU0FGRV9CVUlMRF9MRU5HVEgsXG4gIE1BWF9MRU5HVEgsXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc2FmZVJlID0gZXhwb3J0cy5zYWZlUmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3Qgc2FmZVNyYyA9IGV4cG9ydHMuc2FmZVNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBMRVRURVJEQVNITlVNQkVSID0gJ1thLXpBLVowLTktXSdcblxuLy8gUmVwbGFjZSBzb21lIGdyZWVkeSByZWdleCB0b2tlbnMgdG8gcHJldmVudCByZWdleCBkb3MgaXNzdWVzLiBUaGVzZSByZWdleCBhcmVcbi8vIHVzZWQgaW50ZXJuYWxseSB2aWEgdGhlIHNhZmVSZSBvYmplY3Qgc2luY2UgYWxsIGlucHV0cyBpbiB0aGlzIGxpYnJhcnkgZ2V0XG4vLyBub3JtYWxpemVkIGZpcnN0IHRvIHRyaW0gYW5kIGNvbGxhcHNlIGFsbCBleHRyYSB3aGl0ZXNwYWNlLiBUaGUgb3JpZ2luYWxcbi8vIHJlZ2V4ZXMgYXJlIGV4cG9ydGVkIGZvciB1c2VybGFuZCBjb25zdW1wdGlvbiBhbmQgbG93ZXIgbGV2ZWwgdXNhZ2UuIEFcbi8vIGZ1dHVyZSBicmVha2luZyBjaGFuZ2UgY291bGQgZXhwb3J0IHRoZSBzYWZlciByZWdleCBvbmx5IHdpdGggYSBub3RlIHRoYXRcbi8vIGFsbCBpbnB1dCBzaG91bGQgaGF2ZSBleHRyYSB3aGl0ZXNwYWNlIHJlbW92ZWQuXG5jb25zdCBzYWZlUmVnZXhSZXBsYWNlbWVudHMgPSBbXG4gIFsnXFxcXHMnLCAxXSxcbiAgWydcXFxcZCcsIE1BWF9MRU5HVEhdLFxuICBbTEVUVEVSREFTSE5VTUJFUiwgTUFYX1NBRkVfQlVJTERfTEVOR1RIXSxcbl1cblxuY29uc3QgbWFrZVNhZmVSZWdleCA9ICh2YWx1ZSkgPT4ge1xuICBmb3IgKGNvbnN0IFt0b2tlbiwgbWF4XSBvZiBzYWZlUmVnZXhSZXBsYWNlbWVudHMpIHtcbiAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAuc3BsaXQoYCR7dG9rZW59KmApLmpvaW4oYCR7dG9rZW59ezAsJHttYXh9fWApXG4gICAgICAuc3BsaXQoYCR7dG9rZW59K2ApLmpvaW4oYCR7dG9rZW59ezEsJHttYXh9fWApXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBzYWZlID0gbWFrZVNhZmVSZWdleCh2YWx1ZSlcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcobmFtZSwgaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHNhZmVTcmNbaW5kZXhdID0gc2FmZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbiAgc2FmZVJlW2luZGV4XSA9IG5ldyBSZWdFeHAoc2FmZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUicsICcwfFsxLTldXFxcXGQqJylcbmNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1xcXFxkKycpXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdOT05OVU1FUklDSURFTlRJRklFUicsIGBcXFxcZCpbYS16QS1aLV0ke0xFVFRFUkRBU0hOVU1CRVJ9KmApXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OTE9PU0UnLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgYCg/Oi0oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUxPT1NFJywgYCg/Oi0/KCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRElERU5USUZJRVInLCBgJHtMRVRURVJEQVNITlVNQkVSfStgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFUExBSU4nLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2ApXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7c3JjW3QuQ09FUkNFUExBSU5dfSg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VGVUxMJywgc3JjW3QuQ09FUkNFUExBSU5dICtcbiAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT9gICtcbiAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuQlVJTERdfSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVExGVUxMJywgc3JjW3QuQ09FUkNFRlVMTF0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiQnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/internal/re.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/gtr.js":
/*!******************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/gtr.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(/*! ./outside */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/outside.js\")\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanM/ZjhmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/gtr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/intersects.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/intersects.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDZGQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzP2VjODkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/intersects.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/ltr.js":
/*!******************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/ltr.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const outside = __webpack_require__(/*! ./outside */ \"(rsc)/./node_modules/langsmith/node_modules/semver/ranges/outside.js\")\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBVztBQUNuQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanM/OGU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/ltr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/max-satisfying.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/max-satisfying.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLDZGQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWF4LXNhdGlzZnlpbmcuanM/MDQ0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/max-satisfying.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/min-satisfying.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/min-satisfying.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLDZGQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcz84MjdlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/min-satisfying.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/min-version.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/min-version.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/gt.js\")\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi12ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLDZGQUFrQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsMkZBQWlCOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQjtBQUN2RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanM/ZmQ4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpIHtcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICAgIH1cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/min-version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/outside.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/outside.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/semver.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ../functions/satisfies */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/satisfies.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ../functions/lt */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ../functions/lte */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/lte.js\")\nconst gte = __webpack_require__(/*! ../functions/gte */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/gte.js\")\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLCtGQUFtQjtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBdUI7QUFDbEQsUUFBUSxNQUFNO0FBQ2QsY0FBYyxtQkFBTyxDQUFDLDZGQUFrQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyx5R0FBd0I7QUFDbEQsV0FBVyxtQkFBTyxDQUFDLDJGQUFpQjtBQUNwQyxXQUFXLG1CQUFPLENBQUMsMkZBQWlCO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQyw2RkFBa0I7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLDZGQUFrQjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzPzhmMmMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/outside.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/simplify.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/simplify.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3NpbXBsaWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDRHQUEyQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QixJQUFJO0FBQzNCLE1BQU07QUFDTix1QkFBdUIsSUFBSTtBQUMzQixNQUFNO0FBQ04scUJBQXFCLEtBQUssSUFBSSxJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3NpbXBsaWZ5LmpzP2Y0NjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/simplify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/subset.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/subset.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range.js */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator.js */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"(rsc)/./node_modules/langsmith/node_modules/semver/functions/compare.js\")\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3N1YnNldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsZ0dBQXFCO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLDBHQUEwQjtBQUNyRCxRQUFRLE1BQU07QUFDZCxrQkFBa0IsbUJBQU8sQ0FBQyw0R0FBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQXlCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanM/YmQ3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKV1cbmNvbnN0IG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgICB9XG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/subset.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/to-comparators.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/to-comparators.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyw2RkFBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanM/MzUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/to-comparators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/semver/ranges/valid.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/semver/ranges/valid.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"(rsc)/./node_modules/langsmith/node_modules/semver/classes/range.js\")\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyw2RkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzP2IyYTAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/semver/ranges/valid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25hdGl2ZS5qcz9hNGI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGRlZmF1bHQge1xuICByYW5kb21VVUlEOiBjcnlwdG8ucmFuZG9tVVVJRFxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzPzlhODUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS04XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8ZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmKSQvaTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcz8zOTk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuY29uc3Qgcm5kczhQb29sID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTsgLy8gIyBvZiByYW5kb20gdmFsdWVzIHRvIHByZS1hbGxvY2F0ZVxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG4gIHJldHVybiBybmRzOFBvb2wuc2xpY2UocG9vbFB0ciwgcG9vbFB0ciArPSAxNik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanM/YmM1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgLy9cbiAgLy8gTm90ZSB0byBmdXR1cmUtc2VsZjogTm8sIHlvdSBjYW4ndCByZW1vdmUgdGhlIGB0b0xvd2VyQ2FzZSgpYCBjYWxsLlxuICAvLyBSRUY6IGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzY3NyNpc3N1ZWNvbW1lbnQtMTc1NzM1MTM1MVxuICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTtcbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuICByZXR1cm4gdXVpZDtcbn1cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzPzZkM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmIChuYXRpdmUucmFuZG9tVVVJRCAmJiAhYnVmICYmICFvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5hdGl2ZS5yYW5kb21VVUlEKCk7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcz8wYTk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   Queue: () => (/* binding */ Queue),\n/* harmony export */   mergeRuntimeEnvIntoRunCreate: () => (/* binding */ mergeRuntimeEnvIntoRunCreate)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/prompts.js */ \"(rsc)/./node_modules/langsmith/dist/utils/prompts.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/error.js */ \"(rsc)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction mergeRuntimeEnvIntoRunCreate(run) {\n    const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime,\n        },\n        metadata: {\n            ...envVars,\n            ...(envVars.revision_id || run.revision_id\n                ? { revision_id: run.revision_id ?? envVars.revision_id }\n                : {}),\n            ...metadata,\n        },\n    };\n    return run;\n}\nconst getTracingSamplingRate = () => {\n    const samplingRateStr = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nclass Queue {\n    constructor() {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve) => {\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(item.item).length;\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size,\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop(upToSizeBytes) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes &&\n            this.items.length > 0) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it) => ({ action: it.action, item: it.payload })),\n            () => popped.forEach((it) => it.itemPromiseResolve()),\n        ];\n    }\n}\n// 20 MB\nconst DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20_971_520;\nconst SERVER_INFO_REQUEST_TIMEOUT = 1000;\nclass Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.timeout_ms = config.timeout_ms ?? 12_000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(config.callerOptions ?? {});\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n        });\n        this.hideInputs =\n            config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs =\n            config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.blockOnRootRunFinalization =\n            config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.fetchOptions = config.fetchOptions || {};\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ??\n            \"https://api.smith.langchain.com\";\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `Failed to fetch ${path}`);\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `Failed to fetch ${path}`);\n            const items = transform\n                ? transform(await response.json())\n                : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (!this.filteredPostUuids.has(run.id)) {\n                    sampled.push(run);\n                }\n                else {\n                    this.filteredPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            const sampled = [];\n            for (const run of runs) {\n                if ((run.id !== run.trace_id &&\n                    !this.filteredPostUuids.has(run.trace_id)) ||\n                    Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                }\n                else {\n                    this.filteredPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeBytesLimit ??\n            serverInfo.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_BATCH_SIZE_LIMIT_BYTES);\n    }\n    async drainAutoBatchQueue() {\n        while (this.autoBatchQueue.items.length >= 0) {\n            const [batch, done] = this.autoBatchQueue.pop(await this._getBatchSizeLimitBytes());\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                const ingestParams = {\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                };\n                const serverInfo = await this._ensureServerInfo();\n                if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n                    await this.multipartIngestRuns(ingestParams);\n                }\n                else {\n                    await this.batchIngestRuns(ingestParams);\n                }\n            }\n            finally {\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        if (item.action === \"create\") {\n            item.item = mergeRuntimeEnvIntoRunCreate(item.item);\n        }\n        const itemPromise = this.autoBatchQueue.push(item);\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        if (immediatelyTriggerBatch ||\n            this.autoBatchQueue.sizeBytes > sizeLimitBytes) {\n            await this.drainAutoBatchQueue().catch(console.error);\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                // This error would happen in the background and is uncatchable\n                // from the outside. So just log instead.\n                void this.drainAutoBatchQueue().catch(console.error);\n            }, oldTimeout\n                ? this.autoBatchAggregationDelayMs\n                : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)()(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: { Accept: \"application/json\" },\n            signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get server info\");\n        return response.json();\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async () => {\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    }\n                    catch (e) {\n                        console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to single calls and default limits.`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo) => {\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(mergedRunCreateParam),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true),\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const serverInfo = await this._ensureServerInfo();\n        if (serverInfo.version === undefined) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of rawBatch.post) {\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of rawBatch.patch) {\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            await this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(batchChunks));\n        }\n    }\n    async _postBatchIngestRuns(body) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        const response = await this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"batch create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async multipartIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []) {\n            const preparedCreate = this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined &&\n                preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []) {\n            preparedUpdateParams.push(this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate) => {\n            return (runCreate.trace_id === undefined || runCreate.dotted_order === undefined);\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {\n            return (runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined);\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 &&\n            preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\"post\", preparedCreateParams],\n            [\"patch\", preparedUpdateParams],\n        ]) {\n            for (const originalPayload of payloads) {\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, ...payload } = originalPayload;\n                const fields = { inputs, outputs, events };\n                // encode the main run payload\n                const stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(payload);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([stringifiedPayload], {\n                        type: `application/json; length=${stringifiedPayload.length}`, // encoding=gzip\n                    }),\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)) {\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(value);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([stringifiedValue], {\n                            type: `application/json; length=${stringifiedValue.length}`,\n                        }),\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, [contentType, content]] of Object.entries(attachments)) {\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([content], {\n                                    type: `${contentType}; length=${content.length}`,\n                                }),\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"));\n    }\n    async _sendMultipartRequest(parts, context) {\n        try {\n            const formData = new FormData();\n            for (const part of parts) {\n                formData.append(part.name, part.payload);\n            }\n            await this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/multipart`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                },\n                body: formData,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n        }\n        catch (e) {\n            let errorMessage = \"Failed to multipart ingest runs\";\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (e instanceof Error) {\n                errorMessage += `: ${e.stack || e.message}`;\n            }\n            else {\n                errorMessage += `: ${String(e)}`;\n            }\n            console.warn(`${errorMessage.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            if (run.end_time !== undefined &&\n                data.parent_run_id === undefined &&\n                this.blockOnRootRunFinalization) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({ action: \"update\", item: data }, true);\n                return;\n            }\n            else {\n                void this.processRunOperation({ action: \"update\", item: data }).catch(console.error);\n            }\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update run\", true);\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"child_run_ids\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\",\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n        };\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            }\n            else {\n                yield* runs;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...(projectIds || []),\n                ...(await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))),\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType,\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/stats`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(filteredPayload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"](),\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"unshare run\", true);\n    }\n    async readRunSharedLink(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"unshare dataset\", true);\n    }\n    async readSharedDataset(shareToken) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */\n    async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach((v) => urlParams.append(key, v));\n            }\n            else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${result.detail.join(\"\\n\")}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example) => ({\n            ...example,\n            _hostUrl: this.getHostUrl(),\n        }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create project\");\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update project\");\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName, }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({ projectId, projectName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName, }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({ datasetId, datasetName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId_);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete session ${projectId_} (${projectName})`, true);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"upload CSV\");\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata, } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? { metadata } : undefined,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create dataset\");\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName, }) {\n        try {\n            await this.readDataset({ datasetId, datasetName });\n            return true;\n        }\n        catch (e) {\n            if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error &&\n                e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */\n    async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(_datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${_datasetId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update dataset\");\n        return (await response.json());\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async indexDataset({ datasetId, datasetName, tag, }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (!datasetId_) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const data = {\n            tag: tag,\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/index`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"index dataset\");\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */\n    async similarExamples(inputs, datasetId, limit, { filter, } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs,\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/search`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"fetch similar examples\");\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId, metadata, split, sourceRunId, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n            metadata,\n            split,\n            source_run_id: sourceRunId,\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create example\");\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, metadata, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                metadata: metadata ? metadata[idx] : undefined,\n                split: props.splits ? props.splits[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n            };\n        });\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create examples\");\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations)\n            ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits) {\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        let i = 0;\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            for (const example of examples) {\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update example\");\n        const result = await response.json();\n        return result;\n    }\n    async updateExamples(update) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples/bulk`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update examples\");\n        const result = await response.json();\n        return result;\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id) => {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id);\n                return id;\n            }),\n            remove,\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/splits`, {\n            method: \"PUT\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update dataset splits\", true);\n    }\n    /**\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n     */\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_5__.warnOnce)(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n        return feedbacks[0];\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"](),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId,\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create feedback\", true);\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update feedback\", true);\n    }\n    async readFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId - The ID of the run.\n     * @param feedbackKey - The feedback key.\n     * @param options - Additional options for the token.\n     * @param options.expiration - The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0],\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {},\n        };\n        if (metadata)\n            body.extra[\"metadata\"] = metadata;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/comparative`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        return await response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        }\n        else {\n            results_ = [results];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults) {\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            }\n            else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\",\n            }));\n        }\n        return [evalResults, feedbacks];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */\n    /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */\n    async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i) => {\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name)\n            params.append(\"name\", name);\n        if (nameContains)\n            params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit)\n                break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */\n    async createAnnotationQueue(options) {\n        const { name, description, queueId } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"](),\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined))),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create annotation queue\");\n        const data = await response.json();\n        return data;\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueue object\n     */\n    async readAnnotationQueue(queueId) {\n        // TODO: Replace when actual endpoint is added\n        const queueIteratorResult = await this.listAnnotationQueues({\n            queueIds: [queueId],\n        }).next();\n        if (queueIteratorResult.done) {\n            throw new Error(`Annotation queue with ID ${queueId} not found`);\n        }\n        return queueIteratorResult.value;\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */\n    async updateAnnotationQueue(queueId, options) {\n        const { name, description } = options;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ name, description }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update annotation queue\");\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */\n    async deleteAnnotationQueue(queueId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"DELETE\",\n            headers: { ...this.headers, Accept: \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"delete annotation queue\");\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */\n    async addRunsToAnnotationQueue(queueId, runIds) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/runs`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(runIds.map((id, i) => (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, `runIds[${i}]`).toString())),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"add runs to annotation queue\");\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */\n    async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${baseUrl}/${index}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get run from annotation queue\");\n        return await response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const res = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const json = await res.json();\n        if (!res.ok) {\n            const detail = typeof json.detail === \"string\"\n                ? json.detail\n                : JSON.stringify(json.detail);\n            const error = new Error(`Error ${res.status}: ${res.statusText}\\n${detail}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            error.statusCode = res.status;\n            throw error;\n        }\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/likes/${owner}/${promptName}`, {\n            method: \"POST\",\n            body: JSON.stringify({ like: like }),\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `${like ? \"like\" : \"unlike\"} prompt`);\n        return await response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            }\n            else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        }\n        else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            }\n            else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res) => res.repos)) {\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (response.status === 404) {\n            return null;\n        }\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get prompt\");\n        const result = await response.json();\n        if (result.repo) {\n            return result.repo;\n        }\n        else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle. \n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...(options?.description && { description: options.description }),\n            ...(options?.readme && { readme: options.readme }),\n            ...(options?.tags && { tags: options.tags }),\n            is_public: !!options?.isPublic,\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create prompt\");\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash\n            ? await this._getLatestCommitHash(`${owner}/${promptName}`)\n            : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash,\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create commit\");\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined)\n            payload.description = options.description;\n        if (options?.readme !== undefined)\n            payload.readme = options.readme;\n        if (options?.tags !== undefined)\n            payload.tags = options.tags;\n        if (options?.isPublic !== undefined)\n            payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined)\n            payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"PATCH\",\n            body: JSON.stringify(payload),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\",\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update prompt\");\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        return await response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const serverInfo = await this._getServerInfo();\n        const useOptimization = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.isVersionGreaterOrEqual)(serverInfo.version, \"0.5.23\");\n        let passedCommitHash = commitHash;\n        if (!useOptimization && commitHash === \"latest\") {\n            const latestCommitHash = await this._getLatestCommitHash(`${owner}/${promptName}`);\n            if (!latestCommitHash) {\n                throw new Error(\"No commits found\");\n            }\n            else {\n                passedCommitHash = latestCommitHash;\n            }\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}/${passedCommitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"pull prompt commit\");\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples,\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */\n    async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel,\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key) => key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic,\n                });\n            }\n        }\n        else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic,\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash,\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */\n    async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\",\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({ datasetId: finalDatasetName })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        }\n        catch (_) {\n            // `.hasDataset` will throw an error if the dataset does not exist.\n            // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined,\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e) => e.inputs),\n                outputs: examples.flatMap((e) => (e.outputs ? [e.outputs] : [])),\n                datasetId: dataset.id,\n            });\n        }\n        catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` +\n                \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n            return [apiUrl, urlOrToken];\n        }\n        catch (_) {\n            // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname\n                .split(\"/\")\n                .filter((part) => part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [apiUrl, tokenUuid];\n            }\n            else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */\n    awaitPendingTraceBatches() {\n        return Promise.all(this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUN5QjtBQUNzQztBQUMwQjtBQUM3RTtBQUNLO0FBQ0g7QUFDMEM7QUFDbkM7QUFDYztBQUN3QjtBQUNqRjtBQUNQLHVCQUF1QixvRUFBcUI7QUFDNUMsb0JBQW9CLDBFQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhFQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGFBQWE7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQiw4RUFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUNBQXFDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanM/ODlmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUsIGlzTGFuZ0NoYWluTWVzc2FnZSwgfSBmcm9tIFwiLi91dGlscy9tZXNzYWdlcy5qc1wiO1xuaW1wb3J0IHsgZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhLCBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRVdWlkIH0gZnJvbSBcIi4vdXRpbHMvX3V1aWQuanNcIjtcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSBcIi4vdXRpbHMvd2Fybi5qc1wiO1xuaW1wb3J0IHsgaXNWZXJzaW9uR3JlYXRlck9yRXF1YWwsIHBhcnNlUHJvbXB0SWRlbnRpZmllciwgfSBmcm9tIFwiLi91dGlscy9wcm9tcHRzLmpzXCI7XG5pbXBvcnQgeyByYWlzZUZvclN0YXR1cyB9IGZyb20gXCIuL3V0aWxzL2Vycm9yLmpzXCI7XG5pbXBvcnQgeyBfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiB9IGZyb20gXCIuL3NpbmdsZXRvbnMvZmV0Y2guanNcIjtcbmltcG9ydCB7IHN0cmluZ2lmeSBhcyBzdHJpbmdpZnlGb3JUcmFjaW5nIH0gZnJvbSBcIi4vdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGUocnVuKSB7XG4gICAgY29uc3QgcnVudGltZUVudiA9IGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IGVudlZhcnMgPSBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEoKTtcbiAgICBjb25zdCBleHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhLm1ldGFkYXRhO1xuICAgIHJ1bi5leHRyYSA9IHtcbiAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgIC4uLnJ1bnRpbWVFbnYsXG4gICAgICAgICAgICAuLi5leHRyYT8ucnVudGltZSxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLmVudlZhcnMsXG4gICAgICAgICAgICAuLi4oZW52VmFycy5yZXZpc2lvbl9pZCB8fCBydW4ucmV2aXNpb25faWRcbiAgICAgICAgICAgICAgICA/IHsgcmV2aXNpb25faWQ6IHJ1bi5yZXZpc2lvbl9pZCA/PyBlbnZWYXJzLnJldmlzaW9uX2lkIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHJ1bjtcbn1cbmNvbnN0IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlU3RyID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlRSQUNJTkdfU0FNUExJTkdfUkFURVwiKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlU3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlID0gcGFyc2VGbG9hdChzYW1wbGluZ1JhdGVTdHIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGUgPCAwIHx8IHNhbXBsaW5nUmF0ZSA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMQU5HU01JVEhfVFJBQ0lOR19TQU1QTElOR19SQVRFIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxIGlmIHNldC4gR290OiAke3NhbXBsaW5nUmF0ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsaW5nUmF0ZTtcbn07XG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgaXNMb2NhbGhvc3QgPSAodXJsKSA9PiB7XG4gICAgY29uc3Qgc3RyaXBwZWRVcmwgPSB1cmwucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJcIikucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiXCIpO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gc3RyaXBwZWRVcmwuc3BsaXQoXCIvXCIpWzBdLnNwbGl0KFwiOlwiKVswXTtcbiAgICByZXR1cm4gKGhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiIHx8IGhvc3RuYW1lID09PSBcIjEyNy4wLjAuMVwiIHx8IGhvc3RuYW1lID09PSBcIjo6MVwiKTtcbn07XG5hc3luYyBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJpbVF1b3RlcyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9eXCIoLiopXCIkLywgXCIkMVwiKVxuICAgICAgICAucmVwbGFjZSgvXicoLiopJyQvLCBcIiQxXCIpO1xufVxuY29uc3QgaGFuZGxlNDI5ID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlPy5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJyZXRyeS1hZnRlclwiKSA/PyBcIjMwXCIsIDEwKSAqIDEwMDA7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlBZnRlcikpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGRpcmVjdGx5IGFmdGVyIGNhbGxpbmcgdGhpcyBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbCBiYWNrIHRvIGV4aXN0aW5nIHN0YXR1cyBjaGVja3NcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0IGNsYXNzIFF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXRlbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaXplQnl0ZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zWzBdO1xuICAgIH1cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgbGV0IGl0ZW1Qcm9taXNlUmVzb2x2ZTtcbiAgICAgICAgY29uc3QgaXRlbVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBpdGVtUHJvbWlzZVJlc29sdmUgaXMgc3luY2hyb25vdXMgd2l0aCBwcm9taXNlIGNyZWF0aW9uOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9Qcm9taXNlXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHN0cmluZ2lmeUZvclRyYWNpbmcoaXRlbS5pdGVtKS5sZW5ndGg7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICBhY3Rpb246IGl0ZW0uYWN0aW9uLFxuICAgICAgICAgICAgcGF5bG9hZDogaXRlbS5pdGVtLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlUmVzb2x2ZTogaXRlbVByb21pc2VSZXNvbHZlLFxuICAgICAgICAgICAgaXRlbVByb21pc2UsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaXplQnl0ZXMgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgIH1cbiAgICBwb3AodXBUb1NpemVCeXRlcykge1xuICAgICAgICBpZiAodXBUb1NpemVCeXRlcyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBieXRlcyB0byBwb3Agb2ZmIG1heSBub3QgYmUgbGVzcyB0aGFuIDEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgcG9wcGVkU2l6ZUJ5dGVzID0gMDtcbiAgICAgICAgLy8gUG9wIGl0ZW1zIHVudGlsIHdlIHJlYWNoIG9yIGV4Y2VlZCB0aGUgc2l6ZSBsaW1pdFxuICAgICAgICB3aGlsZSAocG9wcGVkU2l6ZUJ5dGVzICsgKHRoaXMucGVlaygpPy5zaXplID8/IDApIDwgdXBUb1NpemVCeXRlcyAmJlxuICAgICAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBwb3BwZWRTaXplQnl0ZXMgKz0gaXRlbS5zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZUJ5dGVzIC09IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIG9uIHRoZSBxdWV1ZSB3ZSB3ZXJlIHVuYWJsZSB0byBwb3AsXG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIGl0IGFzIGEgc2luZ2xlIGJhdGNoLlxuICAgICAgICBpZiAocG9wcGVkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHBvcHBlZFNpemVCeXRlcyArPSBpdGVtLnNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemVCeXRlcyAtPSBpdGVtLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBvcHBlZC5tYXAoKGl0KSA9PiAoeyBhY3Rpb246IGl0LmFjdGlvbiwgaXRlbTogaXQucGF5bG9hZCB9KSksXG4gICAgICAgICAgICAoKSA9PiBwb3BwZWQuZm9yRWFjaCgoaXQpID0+IGl0Lml0ZW1Qcm9taXNlUmVzb2x2ZSgpKSxcbiAgICAgICAgXTtcbiAgICB9XG59XG4vLyAyMCBNQlxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQkFUQ0hfU0laRV9MSU1JVF9CWVRFUyA9IDIwXzk3MV81MjA7XG5jb25zdCBTRVJWRVJfSU5GT19SRVFVRVNUX1RJTUVPVVQgPSAxMDAwO1xuZXhwb3J0IGNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpS2V5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaVVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3ZWJVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoSW5nZXN0Q2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpbWVvdXRfbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RlbmFudElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlSW5wdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZGVPdXRwdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdTYW1wbGVSYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbHRlcmVkUG9zdFV1aWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRyYWNpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgUXVldWUoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hJbml0aWFsRGVsYXlNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMjUwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDUwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFNpemVCeXRlc0xpbWl0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZldGNoT3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXR0aW5nc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NlcnZlckluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2dldFNlcnZlckluZm9Qcm9taXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBDbGllbnQuZ2V0RGVmYXVsdENsaWVudENvbmZpZygpO1xuICAgICAgICB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID0gZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZSgpO1xuICAgICAgICB0aGlzLmFwaVVybCA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaVVybCA/PyBkZWZhdWx0Q29uZmlnLmFwaVVybCkgPz8gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuYXBpVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdGhpcy5hcGlVcmwgPSB0aGlzLmFwaVVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlLZXkgPz8gZGVmYXVsdENvbmZpZy5hcGlLZXkpO1xuICAgICAgICB0aGlzLndlYlVybCA9IHRyaW1RdW90ZXMoY29uZmlnLndlYlVybCA/PyBkZWZhdWx0Q29uZmlnLndlYlVybCk7XG4gICAgICAgIGlmICh0aGlzLndlYlVybD8uZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMud2ViVXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXRfbXMgPSBjb25maWcudGltZW91dF9tcyA/PyAxMl8wMDA7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KTtcbiAgICAgICAgdGhpcy5iYXRjaEluZ2VzdENhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICAuLi4oY29uZmlnLmNhbGxlck9wdGlvbnMgPz8ge30pLFxuICAgICAgICAgICAgb25GYWlsZWRSZXNwb25zZUhvb2s6IGhhbmRsZTQyOSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGlkZUlucHV0cyA9XG4gICAgICAgICAgICBjb25maWcuaGlkZUlucHV0cyA/PyBjb25maWcuYW5vbnltaXplciA/PyBkZWZhdWx0Q29uZmlnLmhpZGVJbnB1dHM7XG4gICAgICAgIHRoaXMuaGlkZU91dHB1dHMgPVxuICAgICAgICAgICAgY29uZmlnLmhpZGVPdXRwdXRzID8/IGNvbmZpZy5hbm9ueW1pemVyID8/IGRlZmF1bHRDb25maWcuaGlkZU91dHB1dHM7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVHJhY2luZyA9IGNvbmZpZy5hdXRvQmF0Y2hUcmFjaW5nID8/IHRoaXMuYXV0b0JhdGNoVHJhY2luZztcbiAgICAgICAgdGhpcy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiA9XG4gICAgICAgICAgICBjb25maWcuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gPz8gdGhpcy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbjtcbiAgICAgICAgdGhpcy5iYXRjaFNpemVCeXRlc0xpbWl0ID0gY29uZmlnLmJhdGNoU2l6ZUJ5dGVzTGltaXQ7XG4gICAgICAgIHRoaXMuZmV0Y2hPcHRpb25zID0gY29uZmlnLmZldGNoT3B0aW9ucyB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDbGllbnRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJBUElfS0VZXCIpO1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiRU5EUE9JTlRcIikgPz9cbiAgICAgICAgICAgIFwiaHR0cHM6Ly9hcGkuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICBjb25zdCBoaWRlSW5wdXRzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkhJREVfSU5QVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgY29uc3QgaGlkZU91dHB1dHMgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiSElERV9PVVRQVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwaVVybDogYXBpVXJsLFxuICAgICAgICAgICAgYXBpS2V5OiBhcGlLZXksXG4gICAgICAgICAgICB3ZWJVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhpZGVJbnB1dHM6IGhpZGVJbnB1dHMsXG4gICAgICAgICAgICBoaWRlT3V0cHV0czogaGlkZU91dHB1dHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEhvc3RVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLndlYlVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTG9jYWxob3N0KHRoaXMuYXBpVXJsKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLmluY2x1ZGVzKFwiL2FwaVwiKSAmJlxuICAgICAgICAgICAgIXRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5lbmRzV2l0aChcImFwaVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLmFwaVVybC5yZXBsYWNlKFwiL2FwaVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJkZXZcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiZXVcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2V1LnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL3NtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiOiBgbGFuZ3NtaXRoLWpzLyR7X192ZXJzaW9uX199YCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gYCR7dGhpcy5hcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgcHJvY2Vzc0lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oaWRlSW5wdXRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBwcm9jZXNzT3V0cHV0cyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaGlkZU91dHB1dHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZU91dHB1dHMob3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIHByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhydW4pIHtcbiAgICAgICAgY29uc3QgcnVuUGFyYW1zID0geyAuLi5ydW4gfTtcbiAgICAgICAgaWYgKHJ1blBhcmFtcy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLmlucHV0cyA9IHRoaXMucHJvY2Vzc0lucHV0cyhydW5QYXJhbXMuaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuUGFyYW1zLm91dHB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1blBhcmFtcy5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuUGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcXVlcnlQYXJhbXM/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc1N0cmluZ31gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0UGFnaW5hdGVkKHBhdGgsIHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJvZmZzZXRcIikpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcImxpbWl0XCIpKSB8fCAxMDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJvZmZzZXRcIiwgU3RyaW5nKG9mZnNldCkpO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKGxpbWl0KSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cXVlcnlQYXJhbXN9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9YCk7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChwYXRoLCBib2R5ID0gbnVsbCwgcmVxdWVzdE1ldGhvZCA9IFwiUE9TVFwiLCBkYXRhS2V5ID0gXCJydW5zXCIpIHtcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IGJvZHkgPyB7IC4uLmJvZHkgfSA6IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfSR7cGF0aH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0TWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHlQYXJhbXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHlbZGF0YUtleV0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHJlc3BvbnNlQm9keVtkYXRhS2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvcnMgPSByZXNwb25zZUJvZHkuY3Vyc29ycztcbiAgICAgICAgICAgIGlmICghY3Vyc29ycykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJzb3JzLm5leHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHlQYXJhbXMuY3Vyc29yID0gY3Vyc29ycy5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9maWx0ZXJGb3JTYW1wbGluZyhydW5zLCBwYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBydW5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5oYXMocnVuLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1biBvZiBydW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKChydW4uaWQgIT09IHJ1bi50cmFjZV9pZCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5oYXMocnVuLnRyYWNlX2lkKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSA8IHRoaXMudHJhY2luZ1NhbXBsZVJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmFkZChydW4uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHRoaXMuYmF0Y2hTaXplQnl0ZXNMaW1pdCA/P1xuICAgICAgICAgICAgc2VydmVySW5mby5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0X2J5dGVzID8/XG4gICAgICAgICAgICBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMpO1xuICAgIH1cbiAgICBhc3luYyBkcmFpbkF1dG9CYXRjaFF1ZXVlKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5hdXRvQmF0Y2hRdWV1ZS5pdGVtcy5sZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgW2JhdGNoLCBkb25lXSA9IHRoaXMuYXV0b0JhdGNoUXVldWUucG9wKGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKSk7XG4gICAgICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZ2VzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuQ3JlYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuVXBkYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcInVwZGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckluZm8/LmJhdGNoX2luZ2VzdF9jb25maWc/LnVzZV9tdWx0aXBhcnRfZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tdWx0aXBhcnRJbmdlc3RSdW5zKGluZ2VzdFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0UnVucyhpbmdlc3RQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUnVuT3BlcmF0aW9uKGl0ZW0sIGltbWVkaWF0ZWx5VHJpZ2dlckJhdGNoKSB7XG4gICAgICAgIGNvbnN0IG9sZFRpbWVvdXQgPSB0aGlzLmF1dG9CYXRjaFRpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmF1dG9CYXRjaFRpbWVvdXQpO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpdGVtLmFjdGlvbiA9PT0gXCJjcmVhdGVcIikge1xuICAgICAgICAgICAgaXRlbS5pdGVtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZShpdGVtLml0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9taXNlID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICBjb25zdCBzaXplTGltaXRCeXRlcyA9IGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKTtcbiAgICAgICAgaWYgKGltbWVkaWF0ZWx5VHJpZ2dlckJhdGNoIHx8XG4gICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFF1ZXVlLnNpemVCeXRlcyA+IHNpemVMaW1pdEJ5dGVzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRyYWluQXV0b0JhdGNoUXVldWUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hRdWV1ZS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBlcnJvciB3b3VsZCBoYXBwZW4gaW4gdGhlIGJhY2tncm91bmQgYW5kIGlzIHVuY2F0Y2hhYmxlXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0c2lkZS4gU28ganVzdCBsb2cgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfSwgb2xkVGltZW91dFxuICAgICAgICAgICAgICAgID8gdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcbiAgICAgICAgICAgICAgICA6IHRoaXMuYXV0b0JhdGNoSW5pdGlhbERlbGF5TXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2dldEZldGNoSW1wbGVtZW50YXRpb24oKShgJHt0aGlzLmFwaVVybH0vaW5mb2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KFNFUlZFUl9JTkZPX1JFUVVFU1RfVElNRU9VVCksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImdldCBzZXJ2ZXIgaW5mb1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgX2Vuc3VyZVNlcnZlckluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnZlckluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2dldFNlcnZlckluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbV0FSTklOR106IExhbmdTbWl0aCBmYWlsZWQgdG8gZmV0Y2ggaW5mbyBvbiBzdXBwb3J0ZWQgb3BlcmF0aW9ucy4gRmFsbGluZyBiYWNrIHRvIHNpbmdsZSBjYWxscyBhbmQgZGVmYXVsdCBsaW1pdHMuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckluZm8gPz8ge307XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZS50aGVuKChzZXJ2ZXJJbmZvKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VydmVySW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VydmVySW5mbztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5fZ2V0KFwiL3NldHRpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHRpbmdzO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSdW4ocnVuKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW3J1bl0pLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbl9uYW1lID0gcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgZGVsZXRlIHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHtcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lID8/IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBydW5DcmVhdGUudHJhY2VfaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgIGl0ZW06IHJ1bkNyZWF0ZSxcbiAgICAgICAgICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZFJ1bkNyZWF0ZVBhcmFtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZShydW5DcmVhdGUpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IHN0cmluZ2lmeUZvclRyYWNpbmcobWVyZ2VkUnVuQ3JlYXRlUGFyYW0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoIGluZ2VzdC91cHNlcnQgbXVsdGlwbGUgcnVucyBpbiB0aGUgTGFuZ3NtaXRoIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gcnVuc1xuICAgICAqL1xuICAgIGFzeW5jIGJhdGNoSW5nZXN0UnVucyh7IHJ1bkNyZWF0ZXMsIHJ1blVwZGF0ZXMsIH0pIHtcbiAgICAgICAgaWYgKHJ1bkNyZWF0ZXMgPT09IHVuZGVmaW5lZCAmJiBydW5VcGRhdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBydW5DcmVhdGVzPy5tYXAoKGNyZWF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoY3JlYXRlKSkgPz8gW107XG4gICAgICAgIGxldCBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHJ1blVwZGF0ZXM/Lm1hcCgodXBkYXRlKSA9PiB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh1cGRhdGUpKSA/PyBbXTtcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0JhdGNoID0ge1xuICAgICAgICAgICAgcG9zdDogdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcocHJlcGFyZWRDcmVhdGVQYXJhbXMpLFxuICAgICAgICAgICAgcGF0Y2g6IHRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKHByZXBhcmVkVXBkYXRlUGFyYW1zLCB0cnVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFyYXdCYXRjaC5wb3N0Lmxlbmd0aCAmJiAhcmF3QmF0Y2gucGF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgaWYgKHNlcnZlckluZm8udmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRyYWNpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlcGFyZWRDcmVhdGVQYXJhbSBvZiByYXdCYXRjaC5wb3N0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVSdW4ocHJlcGFyZWRDcmVhdGVQYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZXBhcmVkVXBkYXRlUGFyYW0gb2YgcmF3QmF0Y2gucGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlcGFyZWRVcGRhdGVQYXJhbS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlUnVuKHByZXBhcmVkVXBkYXRlUGFyYW0uaWQsIHByZXBhcmVkVXBkYXRlUGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXRjaENodW5rcyA9IHtcbiAgICAgICAgICAgIHBvc3Q6IFtdLFxuICAgICAgICAgICAgcGF0Y2g6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgW1wicG9zdFwiLCBcInBhdGNoXCJdKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hJdGVtcyA9IHJhd0JhdGNoW2tleV0ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGV0IGJhdGNoSXRlbSA9IGJhdGNoSXRlbXMucG9wKCk7XG4gICAgICAgICAgICB3aGlsZSAoYmF0Y2hJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaENodW5rc1trZXldLnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgICAgICAgICBiYXRjaEl0ZW0gPSBiYXRjaEl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaENodW5rcy5wb3N0Lmxlbmd0aCA+IDAgfHwgYmF0Y2hDaHVua3MucGF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9zdEJhdGNoSW5nZXN0UnVucyhzdHJpbmdpZnlGb3JUcmFjaW5nKGJhdGNoQ2h1bmtzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoYm9keSkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJiYXRjaCBjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBtdWx0aXBhcnRJbmdlc3RSdW5zKHsgcnVuQ3JlYXRlcywgcnVuVXBkYXRlcywgfSkge1xuICAgICAgICBpZiAocnVuQ3JlYXRlcyA9PT0gdW5kZWZpbmVkICYmIHJ1blVwZGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYW5zZm9ybSBhbmQgY29udmVydCB0byBkaWN0c1xuICAgICAgICBjb25zdCBhbGxBdHRhY2htZW50cyA9IHt9O1xuICAgICAgICBsZXQgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjcmVhdGUgb2YgcnVuQ3JlYXRlcyA/PyBbXSkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRDcmVhdGUgPSB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhjcmVhdGUpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlLmlkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwcmVwYXJlZENyZWF0ZS5hdHRhY2htZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWxsQXR0YWNobWVudHNbcHJlcGFyZWRDcmVhdGUuaWRdID0gcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHM7XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcy5wdXNoKHByZXBhcmVkQ3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgcnVuVXBkYXRlcyA/PyBbXSkge1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMucHVzaCh0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh1cGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXF1aXJlIHRyYWNlX2lkIGFuZCBkb3R0ZWRfb3JkZXJcbiAgICAgICAgY29uc3QgaW52YWxpZFJ1bkNyZWF0ZSA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLmZpbmQoKHJ1bkNyZWF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChydW5DcmVhdGUudHJhY2VfaWQgPT09IHVuZGVmaW5lZCB8fCBydW5DcmVhdGUuZG90dGVkX29yZGVyID09PSB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludmFsaWRSdW5DcmVhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBhcnQgaW5nZXN0IHJlcXVpcmVzIFwidHJhY2VfaWRcIiBhbmQgXCJkb3R0ZWRfb3JkZXJcIiB0byBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIHJ1bmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludmFsaWRSdW5VcGRhdGUgPSBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5maW5kKChydW5VcGRhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocnVuVXBkYXRlLnRyYWNlX2lkID09PSB1bmRlZmluZWQgfHwgcnVuVXBkYXRlLmRvdHRlZF9vcmRlciA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkUnVuVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwYXJ0IGluZ2VzdCByZXF1aXJlcyBcInRyYWNlX2lkXCIgYW5kIFwiZG90dGVkX29yZGVyXCIgdG8gYmUgc2V0IHdoZW4gdXBkYXRpbmcgYSBydW5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21iaW5lIHBvc3QgYW5kIHBhdGNoIGRpY3RzIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kIHRoZSBydW5zIGluIG11bHRpcGFydCByZXF1ZXN0c1xuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZENvbnRleHQgPSBbXTtcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFttZXRob2QsIHBheWxvYWRzXSBvZiBbXG4gICAgICAgICAgICBbXCJwb3N0XCIsIHByZXBhcmVkQ3JlYXRlUGFyYW1zXSxcbiAgICAgICAgICAgIFtcInBhdGNoXCIsIHByZXBhcmVkVXBkYXRlUGFyYW1zXSxcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcmlnaW5hbFBheWxvYWQgb2YgcGF5bG9hZHMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IGZpZWxkcyB0byBiZSBzZW50IGFzIHNlcGFyYXRlIHBhcnRzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbnB1dHMsIG91dHB1dHMsIGV2ZW50cywgLi4ucGF5bG9hZCB9ID0gb3JpZ2luYWxQYXlsb2FkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHsgaW5wdXRzLCBvdXRwdXRzLCBldmVudHMgfTtcbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIG1haW4gcnVuIHBheWxvYWRcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFBheWxvYWQgPSBzdHJpbmdpZnlGb3JUcmFjaW5nKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke21ldGhvZH0uJHtwYXlsb2FkLmlkfWAsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtzdHJpbmdpZmllZFBheWxvYWRdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgYXBwbGljYXRpb24vanNvbjsgbGVuZ3RoPSR7c3RyaW5naWZpZWRQYXlsb2FkLmxlbmd0aH1gLCAvLyBlbmNvZGluZz1nemlwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgZmllbGRzIHdlIGNvbGxlY3RlZFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkVmFsdWUgPSBzdHJpbmdpZnlGb3JUcmFjaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke21ldGhvZH0uJHtwYXlsb2FkLmlkfS4ke2tleX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW3N0cmluZ2lmaWVkVmFsdWVdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYGFwcGxpY2F0aW9uL2pzb247IGxlbmd0aD0ke3N0cmluZ2lmaWVkVmFsdWUubGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgYXR0YWNobWVudHNcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gYWxsQXR0YWNobWVudHNbcGF5bG9hZC5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFsbEF0dGFjaG1lbnRzW3BheWxvYWQuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgW2NvbnRlbnRUeXBlLCBjb250ZW50XV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0YWNobWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYGF0dGFjaG1lbnQuJHtwYXlsb2FkLmlkfS4ke25hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW2NvbnRlbnRdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgJHtjb250ZW50VHlwZX07IGxlbmd0aD0ke2NvbnRlbnQubGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgY29udGV4dFxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkQ29udGV4dC5wdXNoKGB0cmFjZT0ke3BheWxvYWQudHJhY2VfaWR9LGlkPSR7cGF5bG9hZC5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zZW5kTXVsdGlwYXJ0UmVxdWVzdChhY2N1bXVsYXRlZFBhcnRzLCBhY2N1bXVsYXRlZENvbnRleHQuam9pbihcIjsgXCIpKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmRNdWx0aXBhcnRSZXF1ZXN0KHBhcnRzLCBjb250ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKHBhcnQubmFtZSwgcGFydC5wYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy9tdWx0aXBhcnRgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIkZhaWxlZCB0byBtdWx0aXBhcnQgaW5nZXN0IHJ1bnNcIjtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYDogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGA6ICR7U3RyaW5nKGUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7ZXJyb3JNZXNzYWdlLnRyaW0oKX1cXG5cXG5Db250ZXh0OiAke2NvbnRleHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gdGhpcy5wcm9jZXNzSW5wdXRzKHJ1bi5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1bi5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVbnRhbmdsZSB0eXBlc1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5ydW4sIGlkOiBydW5JZCB9O1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtkYXRhXSwgdHJ1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgZGF0YS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkYXRhLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBkYXRhLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGEgYmF0Y2ggYXMgc29vbiBhcyBhIHJvb3QgdHJhY2UgZW5kcyBhbmQgYmxvY2sgdG8gZW5zdXJlIHRyYWNlIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogc3RyaW5naWZ5Rm9yVHJhY2luZyhydW4pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucyAmJiBydW4uY2hpbGRfcnVuX2lkcykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlBST0pFQ1RcIikgfHwgXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcHJvamVjdC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vby8ke3RlbmFudElkfS9wcm9qZWN0cy9wLyR7c2Vzc2lvbklkfS9yLyR7cnVuLmlkfT9wb2xsPXRydWVgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuSWQpO1xuICAgICAgICAgICAgaWYgKCFydW5fLmFwcF9wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW4gJHtydW5JZH0gaGFzIG5vIGFwcF9wYXRoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5nZXRIb3N0VXJsKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7YmFzZVVybH0ke3J1bl8uYXBwX3BhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcnVuSWQgb3IgcnVuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9sb2FkQ2hpbGRSdW5zKHJ1bikge1xuICAgICAgICBjb25zdCBjaGlsZFJ1bnMgPSBhd2FpdCB0b0FycmF5KHRoaXMubGlzdFJ1bnMoeyBpZDogcnVuLmNoaWxkX3J1bl9pZHMgfSkpO1xuICAgICAgICBjb25zdCB0cmVlbWFwID0ge307XG4gICAgICAgIGNvbnN0IHJ1bnMgPSB7fTtcbiAgICAgICAgLy8gVE9ETzogbWFrZSBkb3R0ZWQgb3JkZXIgcmVxdWlyZWQgd2hlbiB0aGUgbWlncmF0aW9uIGZpbmlzaGVzXG4gICAgICAgIGNoaWxkUnVucy5zb3J0KChhLCBiKSA9PiAoYT8uZG90dGVkX29yZGVyID8/IFwiXCIpLmxvY2FsZUNvbXBhcmUoYj8uZG90dGVkX29yZGVyID8/IFwiXCIpKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiBjaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBydW4gJHtjaGlsZFJ1bi5pZH0gaGFzIG5vIHBhcmVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCBpbiB0cmVlbWFwKSkge1xuICAgICAgICAgICAgICAgIHRyZWVtYXBbY2hpbGRSdW4ucGFyZW50X3J1bl9pZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyZWVtYXBbY2hpbGRSdW4ucGFyZW50X3J1bl9pZF0ucHVzaChjaGlsZFJ1bik7XG4gICAgICAgICAgICBydW5zW2NoaWxkUnVuLmlkXSA9IGNoaWxkUnVuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5jaGlsZF9ydW5zID0gdHJlZW1hcFtydW4uaWRdIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bklkIGluIHRyZWVtYXApIHtcbiAgICAgICAgICAgIGlmIChydW5JZCAhPT0gcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgcnVuc1tydW5JZF0uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgcnVucyBmcm9tIHRoZSBMYW5nU21pdGggc2VydmVyLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0SWQgLSBUaGUgSUQgb2YgdGhlIHByb2plY3QgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBwcm9qZWN0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcGFyZW50UnVuSWQgLSBUaGUgSUQgb2YgdGhlIHBhcmVudCBydW4gdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSB0cmFjZUlkIC0gVGhlIElEIG9mIHRoZSB0cmFjZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHJlZmVyZW5jZUV4YW1wbGVJZCAtIFRoZSBJRCBvZiB0aGUgcmVmZXJlbmNlIGV4YW1wbGUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGlzUm9vdCAtIEluZGljYXRlcyB3aGV0aGVyIHRvIG9ubHkgcmV0dXJuIHJvb3QgcnVucy5cbiAgICAgKiBAcGFyYW0gcnVuVHlwZSAtIFRoZSBydW4gdHlwZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGVycm9yIC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gZmlsdGVyIGJ5IGVycm9yIHJ1bnMuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBydW4gdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSBzdHJpbmcgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgZmlsdGVyIHN0cmluZyB0byBhcHBseSB0byB0aGUgcnVuIHNwYW5zLlxuICAgICAqIEBwYXJhbSB0cmFjZUZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IG9uIHRoZSByb290IHJ1biBvZiB0aGUgdHJhY2UuXG4gICAgICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJ1bnMgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8UnVuPn0gLSBUaGUgcnVucy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyBpbiBhIHByb2plY3RcbiAgICAgKiBjb25zdCBwcm9qZWN0UnVucyA9IGNsaWVudC5saXN0UnVucyh7IHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgTExNIGFuZCBDaGF0IHJ1bnMgaW4gdGhlIGxhc3QgMjQgaG91cnNcbiAgICAgKiBjb25zdCB0b2RheXNMTE1SdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBzdGFydF90aW1lOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMjQgKiA2MCAqIDYwICogMTAwMCksXG4gICAgICogICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCB0cmFjZXMgaW4gYSBwcm9qZWN0XG4gICAgICogY29uc3Qgcm9vdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGV4ZWN1dGlvbl9vcmRlcjogMSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBydW5zIHdpdGhvdXQgZXJyb3JzXG4gICAgICogY29uc3QgY29ycmVjdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGVycm9yOiBmYWxzZSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBydW5zIGJ5IHJ1biBJRFxuICAgICAqIGNvbnN0IHJ1bklkcyA9IFtcbiAgICAgKiAgIFwiYTM2MDkyZDItNGFkNS00ZmI0LTljMGQtMGRiYTlhMmVkODM2XCIsXG4gICAgICogICBcIjkzOThlNmJlLTk2NGYtNGFhNC04YWU5LWFkNzhjZDRiNzA3NFwiLFxuICAgICAqIF07XG4gICAgICogY29uc3Qgc2VsZWN0ZWRSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHsgcnVuX2lkczogcnVuSWRzIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBcImNoYWluXCIgdHlwZSBydW5zIHRoYXQgdG9vayBtb3JlIHRoYW4gMTAgc2Vjb25kcyBhbmQgaGFkIGB0b3RhbF90b2tlbnNgIGdyZWF0ZXIgdGhhbiA1MDAwXG4gICAgICogY29uc3QgY2hhaW5SdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQoZXEocnVuX3R5cGUsIFwiY2hhaW5cIiksIGd0KGxhdGVuY3ksIDEwKSwgZ3QodG90YWxfdG9rZW5zLCA1MDAwKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIGNhbGxlZCBcImV4dHJhY3RvclwiIHdob3NlIHJvb3Qgb2YgdGhlIHRyYWNlIHdhcyBhc3NpZ25lZCBmZWVkYmFjayBcInVzZXJfc2NvcmVcIiBzY29yZSBvZiAxXG4gICAgICogY29uc3QgZ29vZEV4dHJhY3RvclJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2VxKG5hbWUsIFwiZXh0cmFjdG9yXCIpJyxcbiAgICAgKiAgIHRyYWNlRmlsdGVyOiAnYW5kKGVxKGZlZWRiYWNrX2tleSwgXCJ1c2VyX3Njb3JlXCIpLCBlcShmZWVkYmFja19zY29yZSwgMSkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyB0aGF0IHN0YXJ0ZWQgYWZ0ZXIgYSBzcGVjaWZpYyB0aW1lc3RhbXAgYW5kIGVpdGhlciBoYXZlIFwiZXJyb3JcIiBub3QgZXF1YWwgdG8gbnVsbCBvciBhIFwiQ29ycmVjdG5lc3NcIiBmZWVkYmFjayBzY29yZSBlcXVhbCB0byAwXG4gICAgICogY29uc3QgY29tcGxleFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChndChzdGFydF90aW1lLCBcIjIwMjMtMDctMTVUMTI6MzQ6NTZaXCIpLCBvcihuZXEoZXJyb3IsIG51bGwpLCBhbmQoZXEoZmVlZGJhY2tfa2V5LCBcIkNvcnJlY3RuZXNzXCIpLCBlcShmZWVkYmFja19zY29yZSwgMC4wKSkpKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgd2hlcmUgYHRhZ3NgIGluY2x1ZGUgXCJleHBlcmltZW50YWxcIiBvciBcImJldGFcIiBhbmQgYGxhdGVuY3lgIGlzIGdyZWF0ZXIgdGhhbiAyIHNlY29uZHNcbiAgICAgKiBjb25zdCB0YWdnZWRSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQob3IoaGFzKHRhZ3MsIFwiZXhwZXJpbWVudGFsXCIpLCBoYXModGFncywgXCJiZXRhXCIpKSwgZ3QobGF0ZW5jeSwgMikpJyxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdFJ1bnMocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBwYXJlbnRSdW5JZCwgdHJhY2VJZCwgcmVmZXJlbmNlRXhhbXBsZUlkLCBzdGFydFRpbWUsIGV4ZWN1dGlvbk9yZGVyLCBpc1Jvb3QsIHJ1blR5cGUsIGVycm9yLCBpZCwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGxpbWl0LCBzZWxlY3QsIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHByb2plY3RJZHMgPSBbXTtcbiAgICAgICAgaWYgKHByb2plY3RJZCkge1xuICAgICAgICAgICAgcHJvamVjdElkcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdElkKSA/IHByb2plY3RJZCA6IFtwcm9qZWN0SWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdE5hbWVzID0gQXJyYXkuaXNBcnJheShwcm9qZWN0TmFtZSlcbiAgICAgICAgICAgICAgICA/IHByb2plY3ROYW1lXG4gICAgICAgICAgICAgICAgOiBbcHJvamVjdE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdElkc18gPSBhd2FpdCBQcm9taXNlLmFsbChwcm9qZWN0TmFtZXMubWFwKChuYW1lKSA9PiB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IG5hbWUgfSkudGhlbigocHJvamVjdCkgPT4gcHJvamVjdC5pZCkpKTtcbiAgICAgICAgICAgIHByb2plY3RJZHMucHVzaCguLi5wcm9qZWN0SWRzXyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdF9zZWxlY3QgPSBbXG4gICAgICAgICAgICBcImFwcF9wYXRoXCIsXG4gICAgICAgICAgICBcImNoaWxkX3J1bl9pZHNcIixcbiAgICAgICAgICAgIFwiY29tcGxldGlvbl9jb3N0XCIsXG4gICAgICAgICAgICBcImNvbXBsZXRpb25fdG9rZW5zXCIsXG4gICAgICAgICAgICBcImRvdHRlZF9vcmRlclwiLFxuICAgICAgICAgICAgXCJlbmRfdGltZVwiLFxuICAgICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgXCJldmVudHNcIixcbiAgICAgICAgICAgIFwiZXh0cmFcIixcbiAgICAgICAgICAgIFwiZmVlZGJhY2tfc3RhdHNcIixcbiAgICAgICAgICAgIFwiZmlyc3RfdG9rZW5fdGltZVwiLFxuICAgICAgICAgICAgXCJpZFwiLFxuICAgICAgICAgICAgXCJpbnB1dHNcIixcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgXCJvdXRwdXRzXCIsXG4gICAgICAgICAgICBcInBhcmVudF9ydW5faWRcIixcbiAgICAgICAgICAgIFwicGFyZW50X3J1bl9pZHNcIixcbiAgICAgICAgICAgIFwicHJvbXB0X2Nvc3RcIixcbiAgICAgICAgICAgIFwicHJvbXB0X3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLFxuICAgICAgICAgICAgXCJydW5fdHlwZVwiLFxuICAgICAgICAgICAgXCJzZXNzaW9uX2lkXCIsXG4gICAgICAgICAgICBcInN0YXJ0X3RpbWVcIixcbiAgICAgICAgICAgIFwic3RhdHVzXCIsXG4gICAgICAgICAgICBcInRhZ3NcIixcbiAgICAgICAgICAgIFwidG90YWxfY29zdFwiLFxuICAgICAgICAgICAgXCJ0b3RhbF90b2tlbnNcIixcbiAgICAgICAgICAgIFwidHJhY2VfaWRcIixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHNlc3Npb246IHByb2plY3RJZHMubGVuZ3RoID8gcHJvamVjdElkcyA6IG51bGwsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuVHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWQsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHRyYWNlX2ZpbHRlcjogdHJhY2VGaWx0ZXIsXG4gICAgICAgICAgICB0cmVlX2ZpbHRlcjogdHJlZUZpbHRlcixcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uT3JkZXIsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZSA/IHN0YXJ0VGltZS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIHRyYWNlOiB0cmFjZUlkLFxuICAgICAgICAgICAgc2VsZWN0OiBzZWxlY3QgPyBzZWxlY3QgOiBkZWZhdWx0X3NlbGVjdCxcbiAgICAgICAgICAgIGlzX3Jvb3Q6IGlzUm9vdCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJ1bnNZaWVsZGVkID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnNZaWVsZGVkID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVucy5sZW5ndGggKyBydW5zWWllbGRlZCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1J1bnMgPSBydW5zLnNsaWNlKDAsIGxpbWl0IC0gcnVuc1lpZWxkZWQpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogbmV3UnVucztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bnNZaWVsZGVkICs9IHJ1bnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBydW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVuU3RhdHMoeyBpZCwgdHJhY2UsIHBhcmVudFJ1biwgcnVuVHlwZSwgcHJvamVjdE5hbWVzLCBwcm9qZWN0SWRzLCByZWZlcmVuY2VFeGFtcGxlSWRzLCBzdGFydFRpbWUsIGVuZFRpbWUsIGVycm9yLCBxdWVyeSwgZmlsdGVyLCB0cmFjZUZpbHRlciwgdHJlZUZpbHRlciwgaXNSb290LCBkYXRhU291cmNlVHlwZSwgfSkge1xuICAgICAgICBsZXQgcHJvamVjdElkc18gPSBwcm9qZWN0SWRzIHx8IFtdO1xuICAgICAgICBpZiAocHJvamVjdE5hbWVzKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRzXyA9IFtcbiAgICAgICAgICAgICAgICAuLi4ocHJvamVjdElkcyB8fCBbXSksXG4gICAgICAgICAgICAgICAgLi4uKGF3YWl0IFByb21pc2UuYWxsKHByb2plY3ROYW1lcy5tYXAoKG5hbWUpID0+IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogbmFtZSB9KS50aGVuKChwcm9qZWN0KSA9PiBwcm9qZWN0LmlkKSkpKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHJhY2UsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiBwYXJlbnRSdW4sXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuVHlwZSxcbiAgICAgICAgICAgIHNlc3Npb246IHByb2plY3RJZHNfLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGU6IHJlZmVyZW5jZUV4YW1wbGVJZHMsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUsXG4gICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgdHJlZV9maWx0ZXI6IHRyZWVGaWx0ZXIsXG4gICAgICAgICAgICBpc19yb290OiBpc1Jvb3QsXG4gICAgICAgICAgICBkYXRhX3NvdXJjZV90eXBlOiBkYXRhU291cmNlVHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSB0aGUgcGF5bG9hZFxuICAgICAgICBjb25zdCBmaWx0ZXJlZFBheWxvYWQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocGF5bG9hZCkuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy9zdGF0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZFBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2hhcmVSdW4ocnVuSWQsIHsgc2hhcmVJZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZVJ1bihydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVuc2hhcmUgcnVuXCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkUnVuU2hhcmVkTGluayhydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2hhcmVkUnVucyhzaGFyZVRva2VuLCB7IHJ1bklkcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydW5JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJpZFwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9ydW5zJHtxdWVyeVBhcmFtc31gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcnVucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJ1bnM7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0U2hhcmVkU2NoZW1hKGRhdGFzZXRJZCwgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgZGF0YXNldElkIG9yIGRhdGFzZXROYW1lIG11c3QgYmUgZ2l2ZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hhcmVTY2hlbWEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNoYXJlU2NoZW1hLnVybCA9IGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtzaGFyZVNjaGVtYS5zaGFyZV90b2tlbn0vZGA7XG4gICAgICAgIHJldHVybiBzaGFyZVNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgc2hhcmVEYXRhc2V0KGRhdGFzZXRJZCwgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgZGF0YXNldElkIG9yIGRhdGFzZXROYW1lIG11c3QgYmUgZ2l2ZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWQsXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlRGF0YXNldChkYXRhc2V0SWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIGRhdGFzZXRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTaGFyZWREYXRhc2V0KHNoYXJlVG9rZW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNoYXJlZCBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFyZVRva2VuIFRoZSBzaGFyZSB0b2tlbiB0byBnZXQgZXhhbXBsZXMgZm9yLiBBIHNoYXJlIHRva2VuIGlzIHRoZSBVVUlEIChvciBMYW5nU21pdGggVVJMLCBpbmNsdWRpbmcgVVVJRCkgZ2VuZXJhdGVkIHdoZW4gZXhwbGljaXRseSBtYXJraW5nIGFuIGV4YW1wbGUgYXMgcHVibGljLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBsaXN0aW5nIHRoZSBleGFtcGxlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgdW5kZWZpbmVkfSBbb3B0aW9ucy5leGFtcGxlSWRzXSBBIGxpc3Qgb2YgZXhhbXBsZSBJRHMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEV4YW1wbGVbXT59IFRoZSBzaGFyZWQgZXhhbXBsZXMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFNoYXJlZEV4YW1wbGVzKHNoYXJlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIGlmIChvcHRpb25zPy5leGFtcGxlSWRzKSB7XG4gICAgICAgICAgICBwYXJhbXMuaWQgPSBvcHRpb25zLmV4YW1wbGVJZHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4gdXJsUGFyYW1zLmFwcGVuZChrZXksIHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L2V4YW1wbGVzPyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgaWYgKFwiZGV0YWlsXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBzaGFyZWQgZXhhbXBsZXMuXFxuU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31cXG5NZXNzYWdlOiAke3Jlc3VsdC5kZXRhaWwuam9pbihcIlxcblwiKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2hhcmVkIGV4YW1wbGVzOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKChleGFtcGxlKSA9PiAoe1xuICAgICAgICAgICAgLi4uZXhhbXBsZSxcbiAgICAgICAgICAgIF9ob3N0VXJsOiB0aGlzLmdldEhvc3RVcmwoKSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9qZWN0KHsgcHJvamVjdE5hbWUsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCB1cHNlcnQgPSBmYWxzZSwgcHJvamVjdEV4dHJhID0gbnVsbCwgcmVmZXJlbmNlRGF0YXNldElkID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCB1cHNlcnRfID0gdXBzZXJ0ID8gYD91cHNlcnQ9dHJ1ZWAgOiBcIlwiO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucyR7dXBzZXJ0X31gO1xuICAgICAgICBjb25zdCBleHRyYSA9IHByb2plY3RFeHRyYSB8fCB7fTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBleHRyYVtcIm1ldGFkYXRhXCJdID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYm9keVtcInJlZmVyZW5jZV9kYXRhc2V0X2lkXCJdID0gcmVmZXJlbmNlRGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIHByb2plY3RcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHsgbmFtZSA9IG51bGwsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCBwcm9qZWN0RXh0cmEgPSBudWxsLCBlbmRUaW1lID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZH1gO1xuICAgICAgICBsZXQgZXh0cmEgPSBwcm9qZWN0RXh0cmE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmEgPSB7IC4uLihleHRyYSB8fCB7fSksIG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUgPyBuZXcgRGF0ZShlbmRUaW1lKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIHByb2plY3RcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaGFzUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgLy8gVE9ETzogQWRkIGEgaGVhZCByZXF1ZXN0XG4gICAgICAgIGxldCBwYXRoID0gXCIvc2Vzc2lvbnNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZCk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBwcm9qZWN0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCdzIE9LIGFuZCB3ZSdyZSBxdWVyeWluZyBieSBuYW1lLCBuZWVkIHRvIGNoZWNrIHRoZSBsaXN0IGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb2plY3RJZCBxdWVyeWluZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIGluY2x1ZGVTdGF0cywgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZVN0YXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpbmNsdWRlX3N0YXRzXCIsIGluY2x1ZGVTdGF0cy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2plY3RbaWQ9JHtwcm9qZWN0SWR9LCBuYW1lPSR7cHJvamVjdE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvamVjdFVybCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgaWYgKHByb2plY3RJZCA9PT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSB9KTtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Byb2plY3QuaWR9YDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YXNldFVybCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vZGF0YXNldHMvJHtkYXRhc2V0LmlkfWA7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJvamVjdElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2plY3RJZCBvZiBwcm9qZWN0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIHByb2plY3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBuYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VEYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9kYXRhc2V0XCIsIHJlZmVyZW5jZURhdGFzZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmZXJlbmNlRGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoe1xuICAgICAgICAgICAgICAgIGRhdGFzZXROYW1lOiByZWZlcmVuY2VEYXRhc2V0TmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9kYXRhc2V0XCIsIGRhdGFzZXQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VGcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZnJlZVwiLCByZWZlcmVuY2VGcmVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcHJvamVjdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZF87XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IHByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZF8pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zLyR7cHJvamVjdElkX31gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgc2Vzc2lvbiAke3Byb2plY3RJZF99ICgke3Byb2plY3ROYW1lfSlgLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkQ3N2KHsgY3N2RmlsZSwgZmlsZU5hbWUsIGlucHV0S2V5cywgb3V0cHV0S2V5cywgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBuYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy91cGxvYWRgO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGNzdkZpbGUsIGZpbGVOYW1lKTtcbiAgICAgICAgaW5wdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm91dHB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRhdGFfdHlwZVwiLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwbG9hZCBDU1ZcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YXNldChuYW1lLCB7IGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgaW5wdXRzU2NoZW1hLCBvdXRwdXRzU2NoZW1hLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgYm9keS5kYXRhX3R5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRzU2NoZW1hKSB7XG4gICAgICAgICAgICBib2R5LmlucHV0c19zY2hlbWFfZGVmaW5pdGlvbiA9IGlucHV0c1NjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0c1NjaGVtYSkge1xuICAgICAgICAgICAgYm9keS5vdXRwdXRzX3NjaGVtYV9kZWZpbml0aW9uID0gb3V0cHV0c1NjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGRhdGFzZXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgLy8gbGltaXQgdG8gMSByZXN1bHRcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXRbaWQ9JHtkYXRhc2V0SWR9LCBuYW1lPSR7ZGF0YXNldE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaGFzRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibm90IGZvdW5kXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaWZmRGF0YXNldFZlcnNpb25zKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZnJvbVZlcnNpb24sIHRvVmVyc2lvbiwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgZnJvbV92ZXJzaW9uOiB0eXBlb2YgZnJvbVZlcnNpb24gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGZyb21WZXJzaW9uXG4gICAgICAgICAgICAgICAgOiBmcm9tVmVyc2lvbi50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdG9fdmVyc2lvbjogdHlwZW9mIHRvVmVyc2lvbiA9PT0gXCJzdHJpbmdcIiA/IHRvVmVyc2lvbiA6IHRvVmVyc2lvbi50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQoYC9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3ZlcnNpb25zL2RpZmZgLCB1cmxQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKGAke3BhdGh9LyR7ZGF0YXNldElkfS9vcGVuYWlfZnRgKTtcbiAgICAgICAgY29uc3QgZGF0YXNldFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0VGV4dFxuICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAubWFwKChsaW5lKSA9PiBKU09OLnBhcnNlKGxpbmUpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RGF0YXNldHMoeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCwgZGF0YXNldElkcywgZGF0YXNldE5hbWUsIGRhdGFzZXROYW1lQ29udGFpbnMsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldC50b1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZF8gb2YgZGF0YXNldElkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBpZF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBkYXRhc2V0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lQ29udGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVfY29udGFpbnNcIiwgZGF0YXNldE5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJtZXRhZGF0YVwiLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YXNldHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKHBhdGgsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBkYXRhc2V0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBkYXRhc2V0XG4gICAgICogQHBhcmFtIHByb3BzIFRoZSBkYXRhc2V0IGRldGFpbHMgdG8gdXBkYXRlXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgZGF0YXNldFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURhdGFzZXQocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCAuLi51cGRhdGUgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9kYXRhc2V0SWQgPSBkYXRhc2V0SWQgPz8gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGFzc2VydFV1aWQoX2RhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtfZGF0YXNldElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBkYXRhc2V0XCIpO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZURhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtkYXRhc2V0SWRffWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYGRlbGV0ZSAke3BhdGh9YCk7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgaW5kZXhEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgdGFnLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZF8gJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICYmIGRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRhdGFzZXRJZF8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWRffS9pbmRleGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImluZGV4IGRhdGFzZXRcIik7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGV0cyB5b3UgcnVuIGEgc2ltaWxhcml0eSBzZWFyY2ggcXVlcnkgb24gYSBkYXRhc2V0LlxuICAgICAqXG4gICAgICogUmVxdWlyZXMgdGhlIGRhdGFzZXQgdG8gYmUgaW5kZXhlZC4gUGxlYXNlIHNlZSB0aGUgYGluZGV4RGF0YXNldGAgbWV0aG9kIHRvIHNldCB1cCBpbmRleGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dHMgICAgICBUaGUgaW5wdXQgb24gd2hpY2ggdG8gcnVuIHRoZSBzaW1pbGFyaXR5IHNlYXJjaC4gTXVzdCBoYXZlIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICBzYW1lIHNjaGVtYSBhcyB0aGUgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhc2V0SWQgICBUaGUgZGF0YXNldCB0byBzZWFyY2ggZm9yIHNpbWlsYXIgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGltaXQgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGV4YW1wbGVzIHRvIHJldHVybi4gV2lsbCByZXR1cm4gdGhlIHRvcCBgbGltaXRgIG1vc3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc2ltaWxhciBleGFtcGxlcyBpbiBvcmRlciBvZiBtb3N0IHNpbWlsYXIgdG8gbGVhc3Qgc2ltaWxhci4gSWYgbm8gc2ltaWxhclxuICAgICAqICAgICAgICAgICAgICAgICAgICBleGFtcGxlcyBhcmUgZm91bmQsIHJhbmRvbSBleGFtcGxlcyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbHRlciAgICAgIEEgZmlsdGVyIHN0cmluZyB0byBhcHBseSB0byB0aGUgc2VhcmNoLiBPbmx5IGV4YW1wbGVzIHdpbGwgYmUgcmV0dXJuZWQgdGhhdFxuICAgICAqICAgICAgICAgICAgICAgICAgICBtYXRjaCB0aGUgZmlsdGVyIHN0cmluZy4gU29tZSBleGFtcGxlcyBvZiBmaWx0ZXJzXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBlcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIGFuZChuZXEobWV0YWRhdGEubXkubmVzdGVkLmtleSwgXCJ2YWx1ZVwiKSwgbmVxKG1ldGFkYXRhLm15a2V5LCBcInZhbHVlXCIpKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAtIG9yKGVxKG1ldGFkYXRhLm15a2V5LCBcInZhbHVlXCIpLCBlcShtZXRhZGF0YS5teWtleSwgXCJvdGhlcnZhbHVlXCIpKVxuICAgICAqXG4gICAgICogQHJldHVybnMgICAgICAgICAgIEEgbGlzdCBvZiBzaW1pbGFyIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGRhdGFzZXRfaWQgPSBcIjEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMFwiXG4gICAgICogaW5wdXRzID0ge1widGV4dFwiOiBcIkhvdyBtYW55IHBlb3BsZSBsaXZlIGluIEJlcmxpbj9cIn1cbiAgICAgKiBsaW1pdCA9IDVcbiAgICAgKiBleGFtcGxlcyA9IGF3YWl0IGNsaWVudC5zaW1pbGFyRXhhbXBsZXMoaW5wdXRzLCBkYXRhc2V0X2lkLCBsaW1pdClcbiAgICAgKi9cbiAgICBhc3luYyBzaW1pbGFyRXhhbXBsZXMoaW5wdXRzLCBkYXRhc2V0SWQsIGxpbWl0LCB7IGZpbHRlciwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICBpbnB1dHM6IGlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhW1wiZmlsdGVyXCJdID0gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2VhcmNoYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZmV0Y2ggc2ltaWxhciBleGFtcGxlc1wiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0W1wiZXhhbXBsZXNcIl07XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGUoaW5wdXRzLCBvdXRwdXRzLCB7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGNyZWF0ZWRBdCwgZXhhbXBsZUlkLCBtZXRhZGF0YSwgc3BsaXQsIHNvdXJjZVJ1bklkLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0XyA9IGNyZWF0ZWRBdCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBjcmVhdGVkQXRfPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgc3BsaXQsXG4gICAgICAgICAgICBzb3VyY2VfcnVuX2lkOiBzb3VyY2VSdW5JZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9leGFtcGxlc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBleGFtcGxlXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGVzKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRzLCBtZXRhZGF0YSwgc291cmNlUnVuSWRzLCBleGFtcGxlSWRzLCBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXhhbXBsZXMgPSBpbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzID8gb3V0cHV0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSA/IG1ldGFkYXRhW2lkeF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3BsaXQ6IHByb3BzLnNwbGl0cyA/IHByb3BzLnNwbGl0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGlkOiBleGFtcGxlSWRzID8gZXhhbXBsZUlkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IHNvdXJjZVJ1bklkcyA/IHNvdXJjZVJ1bklkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXMvYnVsa2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZvcm1hdHRlZEV4YW1wbGVzKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgZXhhbXBsZXNcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlTExNRXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQgfSwgeyBvdXRwdXQ6IGdlbmVyYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNoYXRFeGFtcGxlKGlucHV0LCBnZW5lcmF0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaW5hbElucHV0ID0gaW5wdXQubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaW5hbE91dHB1dCA9IGlzTGFuZ0NoYWluTWVzc2FnZShnZW5lcmF0aW9ucylcbiAgICAgICAgICAgID8gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA6IGdlbmVyYXRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQ6IGZpbmFsSW5wdXQgfSwgeyBvdXRwdXQ6IGZpbmFsT3V0cHV0IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEV4YW1wbGVzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZXhhbXBsZUlkcywgYXNPZiwgc3BsaXRzLCBpbmxpbmVTM1VybHMsIG1ldGFkYXRhLCBsaW1pdCwgb2Zmc2V0LCBmaWx0ZXIsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGRhdGFzZXQ6IGRhdGFzZXRJZF8gfSk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRfdmVyc2lvbiA9IGFzT2ZcbiAgICAgICAgICAgID8gdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGFzT2ZcbiAgICAgICAgICAgICAgICA6IGFzT2Y/LnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGF0YXNldF92ZXJzaW9uKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiYXNfb2ZcIiwgZGF0YXNldF92ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmxpbmVTM1VybHNfID0gaW5saW5lUzNVcmxzID8/IHRydWU7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpbmxpbmVfczNfdXJsc1wiLCBpbmxpbmVTM1VybHNfLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoZXhhbXBsZUlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBleGFtcGxlSWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwbGl0IG9mIHNwbGl0cykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzcGxpdHNcIiwgc3BsaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTWV0YWRhdGEgPSBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgc2VyaWFsaXplZE1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm9mZnNldFwiLCBvZmZzZXQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiZmlsdGVyXCIsIGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV4YW1wbGVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9leGFtcGxlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4YW1wbGUgb2YgZXhhbXBsZXMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBleGFtcGxlO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGkgPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVFeGFtcGxlKGV4YW1wbGVJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYGRlbGV0ZSAke3BhdGh9YCk7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZShleGFtcGxlSWQsIHVwZGF0ZSkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXMvJHtleGFtcGxlSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGV4YW1wbGVcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZXModXBkYXRlKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXMvYnVsa2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBleGFtcGxlc1wiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBsaXN0RGF0YXNldFNwbGl0cyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGFzT2YsIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldCBuYW1lIG9yIElEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRfdmVyc2lvbiA9IGFzT2ZcbiAgICAgICAgICAgID8gdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGFzT2ZcbiAgICAgICAgICAgICAgICA6IGFzT2Y/LnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGF0YXNldF92ZXJzaW9uKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiYXNfb2ZcIiwgZGF0YXNldF92ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChgL2RhdGFzZXRzLyR7ZGF0YXNldElkX30vc3BsaXRzYCwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVEYXRhc2V0U3BsaXRzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgc3BsaXROYW1lLCBleGFtcGxlSWRzLCByZW1vdmUgPSBmYWxzZSwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0IG5hbWUgb3IgSURcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBzcGxpdF9uYW1lOiBzcGxpdE5hbWUsXG4gICAgICAgICAgICBleGFtcGxlczogZXhhbXBsZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VXVpZChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZW1vdmUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWRffS9zcGxpdHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBkYXRhc2V0IHNwbGl0c1wiLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSBMYW5nU21pdGggdmVyc2lvbnMsIHVzZSBgZXZhbHVhdGVgIGZyb20gYGxhbmdzbWl0aC9ldmFsdWF0aW9uYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGV2YWx1YXRlUnVuKHJ1biwgZXZhbHVhdG9yLCB7IHNvdXJjZUluZm8sIGxvYWRDaGlsZFJ1bnMsIHJlZmVyZW5jZUV4YW1wbGUsIH0gPSB7IGxvYWRDaGlsZFJ1bnM6IGZhbHNlIH0pIHtcbiAgICAgICAgd2Fybk9uY2UoXCJUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIExhbmdTbWl0aCB2ZXJzaW9ucywgdXNlIGBldmFsdWF0ZWAgZnJvbSBgbGFuZ3NtaXRoL2V2YWx1YXRpb25gIGluc3RlYWQuXCIpO1xuICAgICAgICBsZXQgcnVuXztcbiAgICAgICAgaWYgKHR5cGVvZiBydW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuLCB7IGxvYWRDaGlsZFJ1bnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1biA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcnVuKSB7XG4gICAgICAgICAgICBydW5fID0gcnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJ1biB0eXBlOiAke3R5cGVvZiBydW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVSdW4ocnVuXywgcmVmZXJlbmNlRXhhbXBsZSk7XG4gICAgICAgIGNvbnN0IFtfLCBmZWVkYmFja3NdID0gYXdhaXQgdGhpcy5fbG9nRXZhbHVhdGlvbkZlZWRiYWNrKGZlZWRiYWNrUmVzdWx0LCBydW5fLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgcmV0dXJuIGZlZWRiYWNrc1swXTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRmVlZGJhY2socnVuSWQsIGtleSwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIHNvdXJjZUluZm8sIGZlZWRiYWNrU291cmNlVHlwZSA9IFwiYXBpXCIsIHNvdXJjZVJ1bklkLCBmZWVkYmFja0lkLCBmZWVkYmFja0NvbmZpZywgcHJvamVjdElkLCBjb21wYXJhdGl2ZUV4cGVyaW1lbnRJZCwgfSkge1xuICAgICAgICBpZiAoIXJ1bklkICYmICFwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9uZSBvZiBydW5JZCBvciBwcm9qZWN0SWQgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuSWQgJiYgcHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBydW5JZCBvciBwcm9qZWN0SWQgY2FuIGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrX3NvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGZlZWRiYWNrU291cmNlVHlwZSA/PyBcImFwaVwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNvdXJjZUluZm8gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VSdW5JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSkge1xuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0gPSB7IHJ1bl9pZDogc291cmNlUnVuSWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXT8ucnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0ucnVuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgIGlkOiBmZWVkYmFja0lkID8/IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29ycmVjdGlvbixcbiAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U6IGZlZWRiYWNrX3NvdXJjZSxcbiAgICAgICAgICAgIGNvbXBhcmF0aXZlX2V4cGVyaW1lbnRfaWQ6IGNvbXBhcmF0aXZlRXhwZXJpbWVudElkLFxuICAgICAgICAgICAgZmVlZGJhY2tDb25maWcsXG4gICAgICAgICAgICBzZXNzaW9uX2lkOiBwcm9qZWN0SWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9mZWVkYmFja2A7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgZmVlZGJhY2tcIiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBmZWVkYmFjaztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmVlZGJhY2soZmVlZGJhY2tJZCwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIH0pIHtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tVcGRhdGUgPSB7fTtcbiAgICAgICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgc2NvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wic2NvcmVcIl0gPSBzY29yZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJ2YWx1ZVwiXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JyZWN0aW9uICE9PSB1bmRlZmluZWQgJiYgY29ycmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJjb3JyZWN0aW9uXCJdID0gY29ycmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkICYmIGNvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29tbWVudFwiXSA9IGNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrVXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZmVlZGJhY2tcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgJHtwYXRofWApO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RmVlZGJhY2soeyBydW5JZHMsIGZlZWRiYWNrS2V5cywgZmVlZGJhY2tTb3VyY2VUeXBlcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocnVuSWRzKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJydW5cIiwgcnVuSWRzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzb3VyY2VcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmZWVkYmFja3Mgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGZlZWRiYWNrcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VuIGFuZCBVUkwuXG4gICAgICpcbiAgICAgKiBUaGUgdG9rZW4gY2FuIGJlIHVzZWQgdG8gYXV0aG9yaXplIGZlZWRiYWNrIG1ldHJpY3Mgd2l0aG91dFxuICAgICAqIG5lZWRpbmcgYW4gQVBJIGtleS4gVGhpcyBpcyB1c2VmdWwgZm9yIGdpdmluZyBicm93c2VyLWJhc2VkXG4gICAgICogYXBwbGljYXRpb25zIHRoZSBhYmlsaXR5IHRvIHN1Ym1pdCBmZWVkYmFjayB3aXRob3V0IG5lZWRpbmdcbiAgICAgKiB0byBleHBvc2UgYW4gQVBJIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBydW5JZCAtIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEBwYXJhbSBmZWVkYmFja0tleSAtIFRoZSBmZWVkYmFjayBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5leHBpcmF0aW9uIC0gVGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGZWVkYmFja0luZ2VzdFRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4ocnVuSWQsIGZlZWRiYWNrS2V5LCB7IGV4cGlyYXRpb24sIGZlZWRiYWNrQ29uZmlnLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBmZWVkYmFja19rZXk6IGZlZWRiYWNrS2V5LFxuICAgICAgICAgICAgZmVlZGJhY2tfY29uZmlnOiBmZWVkYmFja0NvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2F0XCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cGlyYXRpb24/LmhvdXJzIHx8IGV4cGlyYXRpb24/Lm1pbnV0ZXMgfHwgZXhwaXJhdGlvbj8uZGF5cykge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0ge1xuICAgICAgICAgICAgICAgIGhvdXJzOiAzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrL3Rva2Vuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ29tcGFyYXRpdmVFeHBlcmltZW50KHsgbmFtZSwgZXhwZXJpbWVudElkcywgcmVmZXJlbmNlRGF0YXNldElkLCBjcmVhdGVkQXQsIGRlc2NyaXB0aW9uLCBtZXRhZGF0YSwgaWQsIH0pIHtcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZXhwZXJpbWVudCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZmVyZW5jZURhdGFzZXRJZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRGF0YXNldElkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgIHByb2plY3RJZDogZXhwZXJpbWVudElkc1swXSxcbiAgICAgICAgICAgIH0pKS5yZWZlcmVuY2VfZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZmVyZW5jZURhdGFzZXRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHJlZmVyZW5jZSBkYXRhc2V0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHBlcmltZW50X2lkczogZXhwZXJpbWVudElkcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9kYXRhc2V0X2lkOiByZWZlcmVuY2VEYXRhc2V0SWQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IChjcmVhdGVkQXQgPz8gbmV3IERhdGUoKSk/LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBleHRyYToge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YSlcbiAgICAgICAgICAgIGJvZHkuZXh0cmFbXCJtZXRhZGF0YVwiXSA9IG1ldGFkYXRhO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzL2NvbXBhcmF0aXZlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBwcmVzaWduZWQgZmVlZGJhY2sgdG9rZW5zIGZvciBhIGdpdmVuIHJ1biBJRC5cbiAgICAgKiBAcGFyYW0gcnVuSWQgVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHJldHVybnMgQW4gYXN5bmMgaXRlcmFibGUgb2YgRmVlZGJhY2tJbmdlc3RUb2tlbiBvYmplY3RzLlxuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UHJlc2lnbmVkRmVlZGJhY2tUb2tlbnMocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBydW5faWQ6IHJ1bklkIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHRva2VucyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZmVlZGJhY2svdG9rZW5zXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0b2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NlbGVjdEV2YWxSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHNfO1xuICAgICAgICBpZiAoXCJyZXN1bHRzXCIgaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0c18gPSByZXN1bHRzLnJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IFtyZXN1bHRzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0c187XG4gICAgfVxuICAgIGFzeW5jIF9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbykge1xuICAgICAgICBjb25zdCBldmFsUmVzdWx0cyA9IHRoaXMuX3NlbGVjdEV2YWxSZXN1bHRzKGV2YWx1YXRvclJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIGV2YWxSZXN1bHRzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlSW5mb18gPSBzb3VyY2VJbmZvIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcy5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICAgICAgc291cmNlSW5mb18gPSB7IC4uLnJlcy5ldmFsdWF0b3JJbmZvLCAuLi5zb3VyY2VJbmZvXyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJ1bklkXyA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzLnRhcmdldFJ1bklkKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcmVzLnRhcmdldFJ1bklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVuKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcnVuLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVlZGJhY2tzLnB1c2goYXdhaXQgdGhpcy5jcmVhdGVGZWVkYmFjayhydW5JZF8sIHJlcy5rZXksIHtcbiAgICAgICAgICAgICAgICBzY29yZTogcmVzLnNjb3JlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXMudmFsdWUsXG4gICAgICAgICAgICAgICAgY29tbWVudDogcmVzLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgY29ycmVjdGlvbjogcmVzLmNvcnJlY3Rpb24sXG4gICAgICAgICAgICAgICAgc291cmNlSW5mbzogc291cmNlSW5mb18sXG4gICAgICAgICAgICAgICAgc291cmNlUnVuSWQ6IHJlcy5zb3VyY2VSdW5JZCxcbiAgICAgICAgICAgICAgICBmZWVkYmFja0NvbmZpZzogcmVzLmZlZWRiYWNrQ29uZmlnLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrU291cmNlVHlwZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXZhbFJlc3VsdHMsIGZlZWRiYWNrc107XG4gICAgfVxuICAgIGFzeW5jIGxvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuX2xvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFQSSBmb3IgbWFuYWdpbmcgYW5ub3RhdGlvbiBxdWV1ZXNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBhbm5vdGF0aW9uIHF1ZXVlcyBvbiB0aGUgTGFuZ1NtaXRoIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBsaXN0aW5nIGFubm90YXRpb24gcXVldWVzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZHMgLSBUaGUgSURzIG9mIHRoZSBxdWV1ZXMgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBxdWV1ZSB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lQ29udGFpbnMgLSBUaGUgc3Vic3RyaW5nIHRoYXQgdGhlIHF1ZXVlIG5hbWUgc2hvdWxkIGNvbnRhaW5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBxdWV1ZXMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgQW5ub3RhdGlvblF1ZXVlIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdEFubm90YXRpb25RdWV1ZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcXVldWVJZHMsIG5hbWUsIG5hbWVDb250YWlucywgbGltaXQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHF1ZXVlSWRzKSB7XG4gICAgICAgICAgICBxdWV1ZUlkcy5mb3JFYWNoKChpZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQsIGBxdWV1ZUlkc1ske2l9XWApO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZHNcIiwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaWYgKG5hbWVDb250YWlucylcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCAobGltaXQgIT09IHVuZGVmaW5lZCA/IE1hdGgubWluKGxpbWl0LCAxMDApIDogMTAwKS50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBxdWV1ZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2Fubm90YXRpb24tcXVldWVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBxdWV1ZXM7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgY291bnQgPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFubm90YXRpb24gcXVldWUgb24gdGhlIExhbmdTbWl0aCBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIEFubm90YXRpb25RdWV1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbm5vdGF0aW9uUXVldWUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uLCBxdWV1ZUlkIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgaWQ6IHF1ZXVlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGJvZHkpLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQpKSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgQW5ub3RhdGlvblF1ZXVlIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRBbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHdoZW4gYWN0dWFsIGVuZHBvaW50IGlzIGFkZGVkXG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlcmF0b3JSZXN1bHQgPSBhd2FpdCB0aGlzLmxpc3RBbm5vdGF0aW9uUXVldWVzKHtcbiAgICAgICAgICAgIHF1ZXVlSWRzOiBbcXVldWVJZF0sXG4gICAgICAgIH0pLm5leHQoKTtcbiAgICAgICAgaWYgKHF1ZXVlSXRlcmF0b3JSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbm5vdGF0aW9uIHF1ZXVlIHdpdGggSUQgJHtxdWV1ZUlkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWVJdGVyYXRvclJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHVwZGF0aW5nIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuZXcgbmFtZSBmb3IgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXNjcmlwdGlvbiAtIFRoZSBuZXcgZGVzY3JpcHRpb24gZm9yIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkZXNjcmlwdGlvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG5hbWUsIGRlc2NyaXB0aW9uIH0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gZGVsZXRlXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZGVsZXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBydW5zIHRvIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIHJ1bklkcyAtIFRoZSBJRHMgb2YgdGhlIHJ1bnMgdG8gYmUgYWRkZWQgdG8gdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyBhZGRSdW5zVG9Bbm5vdGF0aW9uUXVldWUocXVldWVJZCwgcnVuSWRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJ1bklkcy5tYXAoKGlkLCBpKSA9PiBhc3NlcnRVdWlkKGlkLCBgcnVuSWRzWyR7aX1dYCkudG9TdHJpbmcoKSkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImFkZCBydW5zIHRvIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHJ1biBmcm9tIGFuIGFubm90YXRpb24gcXVldWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcnVuIHRvIHJldHJpZXZlXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBSdW5XaXRoQW5ub3RhdGlvblF1ZXVlSW5mbyBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHJ1biBpcyBub3QgZm91bmQgYXQgdGhlIGdpdmVuIGluZGV4IG9yIGZvciBvdGhlciBBUEktcmVsYXRlZCBlcnJvcnNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBgL2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bmA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0ke2Jhc2VVcmx9LyR7aW5kZXh9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImdldCBydW4gZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBfY3VycmVudFRlbmFudElzT3duZXIob3duZXIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICByZXR1cm4gb3duZXIgPT0gXCItXCIgfHwgc2V0dGluZ3MudGVuYW50X2hhbmRsZSA9PT0gb3duZXI7XG4gICAgfVxuICAgIGFzeW5jIF9vd25lckNvbmZsaWN0RXJyb3IoYWN0aW9uLCBvd25lcikge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYENhbm5vdCAke2FjdGlvbn0gZm9yIGFub3RoZXIgdGVuYW50LlxcblxuICAgICAgQ3VycmVudCB0ZW5hbnQ6ICR7c2V0dGluZ3MudGVuYW50X2hhbmRsZX1cXG5cbiAgICAgIFJlcXVlc3RlZCB0ZW5hbnQ6ICR7b3duZXJ9YCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRMYXRlc3RDb21taXRIYXNoKHByb21wdE93bmVyQW5kTmFtZSkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7cHJvbXB0T3duZXJBbmROYW1lfS8/bGltaXQ9JHsxfSZvZmZzZXQ9JHswfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IHR5cGVvZiBqc29uLmRldGFpbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8ganNvbi5kZXRhaWxcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGpzb24uZGV0YWlsKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBFcnJvciAke3Jlcy5zdGF0dXN9OiAke3Jlcy5zdGF0dXNUZXh0fVxcbiR7ZGV0YWlsfWApO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uY29tbWl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb24uY29tbWl0c1swXS5jb21taXRfaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBsaWtlKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vbGlrZXMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGxpa2U6IGxpa2UgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYCR7bGlrZSA/IFwibGlrZVwiIDogXCJ1bmxpa2VcIn0gcHJvbXB0YCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRQcm9tcHRVcmwocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIGNvbW1pdEhhc2hdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vaHViLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX0vJHtjb21taXRIYXNoLnN1YnN0cmluZygwLCA4KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9odWIvJHtvd25lcn0vJHtwcm9tcHROYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaC5zdWJzdHJpbmcoMCwgOCl9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBhd2FpdCB0aGlzLmdldFByb21wdChwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuICEhcHJvbXB0O1xuICAgIH1cbiAgICBhc3luYyBsaWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgdW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0Q29tbWl0cyhwcm9tcHRPd25lckFuZE5hbWUpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjb21taXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChgL2NvbW1pdHMvJHtwcm9tcHRPd25lckFuZE5hbWV9L2AsIG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgKHJlcykgPT4gcmVzLmNvbW1pdHMpKSB7XG4gICAgICAgICAgICB5aWVsZCogY29tbWl0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqbGlzdFByb21wdHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2ZpZWxkXCIsIG9wdGlvbnM/LnNvcnRGaWVsZCA/PyBcInVwZGF0ZWRfYXRcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2RpcmVjdGlvblwiLCBcImRlc2NcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19hcmNoaXZlZFwiLCAoISFvcHRpb25zPy5pc0FyY2hpdmVkKS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19wdWJsaWNcIiwgb3B0aW9ucy5pc1B1YmxpYy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJxdWVyeVwiLCBvcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb21wdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3JlcG9zXCIsIHBhcmFtcywgKHJlcykgPT4gcmVzLnJlcG9zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb21wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZ2V0IHByb21wdFwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0LnJlcG8pIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVwbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICYmICFzZXR0aW5ncy50ZW5hbnRfaGFuZGxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSBwdWJsaWMgcHJvbXB0IHdpdGhvdXQgZmlyc3RcXG5cbiAgICAgICAgY3JlYXRpbmcgYSBMYW5nQ2hhaW4gSHViIGhhbmRsZS4gXG4gICAgICAgIFlvdSBjYW4gYWRkIGEgaGFuZGxlIGJ5IGNyZWF0aW5nIGEgcHVibGljIHByb21wdCBhdDpcXG5cbiAgICAgICAgaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tL3Byb21wdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLl9vd25lckNvbmZsaWN0RXJyb3IoXCJjcmVhdGUgYSBwcm9tcHRcIiwgb3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICByZXBvX2hhbmRsZTogcHJvbXB0TmFtZSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5kZXNjcmlwdGlvbiAmJiB7IGRlc2NyaXB0aW9uOiBvcHRpb25zLmRlc2NyaXB0aW9uIH0pLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnJlYWRtZSAmJiB7IHJlYWRtZTogb3B0aW9ucy5yZWFkbWUgfSksXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8udGFncyAmJiB7IHRhZ3M6IG9wdGlvbnMudGFncyB9KSxcbiAgICAgICAgICAgIGlzX3B1YmxpYzogISFvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy9gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgcHJvbXB0XCIpO1xuICAgICAgICBjb25zdCB7IHJlcG8gfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlcG87XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdChwcm9tcHRJZGVudGlmaWVyLCBvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXJlbnRDb21taXRIYXNoID0gb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaCA9PT0gXCJsYXRlc3RcIiB8fCAhb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaFxuICAgICAgICAgICAgPyBhd2FpdCB0aGlzLl9nZXRMYXRlc3RDb21taXRIYXNoKGAke293bmVyfS8ke3Byb21wdE5hbWV9YClcbiAgICAgICAgICAgIDogb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaDtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG1hbmlmZXN0OiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpLFxuICAgICAgICAgICAgcGFyZW50X2NvbW1pdDogcmVzb2x2ZWRQYXJlbnRDb21taXRIYXNoLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBjb21taXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb21wdFVybChgJHtvd25lcn0vJHtwcm9tcHROYW1lfSR7cmVzdWx0LmNvbW1pdF9oYXNoID8gYDoke3Jlc3VsdC5jb21taXRfaGFzaH1gIDogXCJcIn1gKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwidXBkYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmIChvcHRpb25zPy5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChvcHRpb25zPy5yZWFkbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQucmVhZG1lID0gb3B0aW9ucy5yZWFkbWU7XG4gICAgICAgIGlmIChvcHRpb25zPy50YWdzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLnRhZ3MgPSBvcHRpb25zLnRhZ3M7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19wdWJsaWMgPSBvcHRpb25zLmlzUHVibGljO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNBcmNoaXZlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19hcmNoaXZlZCA9IG9wdGlvbnMuaXNBcmNoaXZlZDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bG9hZCBpcyBlbXB0eVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGF5bG9hZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCB1cGRhdGUgb3B0aW9ucyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3JlcG9zLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIHByb21wdFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwiZGVsZXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3JlcG9zLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgcHVsbFByb21wdENvbW1pdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgY29tbWl0SGFzaF0gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIGNvbnN0IHVzZU9wdGltaXphdGlvbiA9IGlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsKHNlcnZlckluZm8udmVyc2lvbiwgXCIwLjUuMjNcIik7XG4gICAgICAgIGxldCBwYXNzZWRDb21taXRIYXNoID0gY29tbWl0SGFzaDtcbiAgICAgICAgaWYgKCF1c2VPcHRpbWl6YXRpb24gJiYgY29tbWl0SGFzaCA9PT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q29tbWl0SGFzaCA9IGF3YWl0IHRoaXMuX2dldExhdGVzdENvbW1pdEhhc2goYCR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gKTtcbiAgICAgICAgICAgIGlmICghbGF0ZXN0Q29tbWl0SGFzaCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNvbW1pdHMgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXNzZWRDb21taXRIYXNoID0gbGF0ZXN0Q29tbWl0SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfS8ke3Bhc3NlZENvbW1pdEhhc2h9JHtvcHRpb25zPy5pbmNsdWRlTW9kZWwgPyBcIj9pbmNsdWRlX21vZGVsPXRydWVcIiA6IFwiXCJ9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInB1bGwgcHJvbXB0IGNvbW1pdFwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICByZXBvOiBwcm9tcHROYW1lLFxuICAgICAgICAgICAgY29tbWl0X2hhc2g6IHJlc3VsdC5jb21taXRfaGFzaCxcbiAgICAgICAgICAgIG1hbmlmZXN0OiByZXN1bHQubWFuaWZlc3QsXG4gICAgICAgICAgICBleGFtcGxlczogcmVzdWx0LmV4YW1wbGVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIHVzZSBgaW1wb3J0IHsgcHVsbCB9IGZyb20gXCJsYW5nY2hhaW4vaHViXCJgIGluc3RlYWQuXG4gICAgICogVXNpbmcgdGhpcyBtZXRob2QgZGlyZWN0bHkgcmV0dXJucyB0aGUgSlNPTiBzdHJpbmcgb2YgdGhlIHByb21wdCByYXRoZXIgdGhhbiBhIExhbmdDaGFpbiBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfcHVsbFByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb21wdE9iamVjdCA9IGF3YWl0IHRoaXMucHVsbFByb21wdENvbW1pdChwcm9tcHRJZGVudGlmaWVyLCB7XG4gICAgICAgICAgICBpbmNsdWRlTW9kZWw6IG9wdGlvbnM/LmluY2x1ZGVNb2RlbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb21wdCA9IEpTT04uc3RyaW5naWZ5KHByb21wdE9iamVjdC5tYW5pZmVzdCk7XG4gICAgICAgIHJldHVybiBwcm9tcHQ7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgb3IgdXBkYXRlIHByb21wdCBtZXRhZGF0YVxuICAgICAgICBpZiAoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLnNvbWUoKGtleSkgPT4ga2V5ICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnM/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICByZWFkbWU6IG9wdGlvbnM/LnJlYWRtZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucz8udGFncyxcbiAgICAgICAgICAgICAgICAgICAgaXNQdWJsaWM6IG9wdGlvbnM/LmlzUHVibGljLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICByZWFkbWU6IG9wdGlvbnM/LnJlYWRtZSxcbiAgICAgICAgICAgICAgICB0YWdzOiBvcHRpb25zPy50YWdzLFxuICAgICAgICAgICAgICAgIGlzUHVibGljOiBvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucz8ub2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0UHJvbXB0VXJsKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbW1pdCB3aXRoIHRoZSBuZXcgbWFuaWZlc3RcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5jcmVhdGVDb21taXQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucz8ub2JqZWN0LCB7XG4gICAgICAgICAgICBwYXJlbnRDb21taXRIYXNoOiBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmUgYSBwdWJsaWMgZGF0YXNldCB0byB5b3VyIG93biBsYW5nc21pdGggdGVuYW50LlxuICAgICAqIFRoaXMgb3BlcmF0aW9uIGlzIGlkZW1wb3RlbnQuIElmIHlvdSBhbHJlYWR5IGhhdmUgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWUsXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGRvIG5vdGhpbmcuXG4gIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbk9yVXJsIFRoZSB0b2tlbiBvZiB0aGUgcHVibGljIGRhdGFzZXQgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGNsb25pbmcgdGhlIGRhdGFzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZUFwaVVybF0gVGhlIFVSTCBvZiB0aGUgbGFuZ3NtaXRoIHNlcnZlciB3aGVyZSB0aGUgZGF0YSBpcyBob3N0ZWQuIERlZmF1bHRzIHRvIHRoZSBBUEkgVVJMIG9mIHlvdXIgY3VycmVudCBjbGllbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRhdGFzZXROYW1lXSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byBjcmVhdGUgaW4geW91ciB0ZW5hbnQuIERlZmF1bHRzIHRvIHRoZSBuYW1lIG9mIHRoZSBwdWJsaWMgZGF0YXNldC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBjbG9uZVB1YmxpY0RhdGFzZXQodG9rZW5PclVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlQXBpVXJsID0gdGhpcy5hcGlVcmwsIGRhdGFzZXROYW1lIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBbcGFyc2VkQXBpVXJsLCB0b2tlblV1aWRdID0gdGhpcy5wYXJzZVRva2VuT3JVcmwodG9rZW5PclVybCwgc291cmNlQXBpVXJsKTtcbiAgICAgICAgY29uc3Qgc291cmNlQ2xpZW50ID0gbmV3IENsaWVudCh7XG4gICAgICAgICAgICBhcGlVcmw6IHBhcnNlZEFwaVVybCxcbiAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyIEFQSSBrZXkgbm90IG5lZWRlZCBhbnltb3JlIGluIG1vc3QgY2FzZXMsIGJ1dFxuICAgICAgICAgICAgLy8gc29tZSBwcml2YXRlIGRlcGxveW1lbnRzIG1heSBoYXZlIEFQSSBrZXktYmFzZWQgcmF0ZSBsaW1pdGluZ1xuICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCBjYXVzZSB0aGlzIHRvIGZhaWwgaWYgd2UgcHJvdmlkZSBubyB2YWx1ZS5cbiAgICAgICAgICAgIGFwaUtleTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZHMgPSBhd2FpdCBzb3VyY2VDbGllbnQucmVhZFNoYXJlZERhdGFzZXQodG9rZW5VdWlkKTtcbiAgICAgICAgY29uc3QgZmluYWxEYXRhc2V0TmFtZSA9IGRhdGFzZXROYW1lIHx8IGRzLm5hbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5oYXNEYXRhc2V0KHsgZGF0YXNldElkOiBmaW5hbERhdGFzZXROYW1lIH0pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYERhdGFzZXQgJHtmaW5hbERhdGFzZXROYW1lfSBhbHJlYWR5IGV4aXN0cyBpbiB5b3VyIHRlbmFudC4gU2tpcHBpbmcuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBgLmhhc0RhdGFzZXRgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRhdGFzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAgICAvLyBuby1vcCBpbiB0aGF0IGNhc2VcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCBleGFtcGxlcyBmaXJzdCwgdGhlbiBjcmVhdGUgdGhlIGRhdGFzZXRcbiAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBhd2FpdCBzb3VyY2VDbGllbnQubGlzdFNoYXJlZEV4YW1wbGVzKHRva2VuVXVpZCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLmNyZWF0ZURhdGFzZXQoZmluYWxEYXRhc2V0TmFtZSwge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZGF0YVR5cGU6IGRzLmRhdGFfdHlwZSB8fCBcImt2XCIsXG4gICAgICAgICAgICBpbnB1dHNTY2hlbWE6IGRzLmlucHV0c19zY2hlbWFfZGVmaW5pdGlvbiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdXRwdXRzU2NoZW1hOiBkcy5vdXRwdXRzX3NjaGVtYV9kZWZpbml0aW9uID8/IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUV4YW1wbGVzKHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGV4YW1wbGVzLm1hcCgoZSkgPT4gZS5pbnB1dHMpLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IGV4YW1wbGVzLmZsYXRNYXAoKGUpID0+IChlLm91dHB1dHMgPyBbZS5vdXRwdXRzXSA6IFtdKSksXG4gICAgICAgICAgICAgICAgZGF0YXNldElkOiBkYXRhc2V0LmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGNyZWF0aW5nIGRhdGFzZXQgJHtmaW5hbERhdGFzZXROYW1lfS4gYCArXG4gICAgICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIGRlbGV0ZSBpdCBtYW51YWxseS5cIik7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlVG9rZW5PclVybCh1cmxPclRva2VuLCBhcGlVcmwsIG51bVBhcnRzID0gMiwga2luZCA9IFwiZGF0YXNldFwiKSB7XG4gICAgICAgIC8vIFRyeSBwYXJzaW5nIGFzIFVVSURcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQodXJsT3JUb2tlbik7IC8vIFdpbGwgdGhyb3cgaWYgaXQncyBub3QgYSBVVUlELlxuICAgICAgICAgICAgcmV0dXJuIFthcGlVcmwsIHVybE9yVG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBuby1vcCBpZiBpdCdzIG5vdCBhIHV1aWRcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBhcyBVUkxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsT3JUb2tlbik7XG4gICAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBwYXJzZWRVcmwucGF0aG5hbWVcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocGFydCkgPT4gcGFydCAhPT0gXCJcIik7XG4gICAgICAgICAgICBpZiAocGF0aFBhcnRzLmxlbmd0aCA+PSBudW1QYXJ0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuVXVpZCA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gbnVtUGFydHNdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYXBpVXJsLCB0b2tlblV1aWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyAke2tpbmR9IFVSTDogJHt1cmxPclRva2VufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyAke2tpbmR9IFVSTCBvciB0b2tlbjogJHt1cmxPclRva2VufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF3YWl0cyBhbGwgcGVuZGluZyB0cmFjZSBiYXRjaGVzLiBVc2VmdWwgZm9yIGVudmlyb25tZW50cyB3aGVyZVxuICAgICAqIHlvdSBuZWVkIHRvIGJlIHN1cmUgdGhhdCBhbGwgdHJhY2luZyByZXF1ZXN0cyBmaW5pc2ggYmVmb3JlIGV4ZWN1dGlvbiBlbmRzLFxuICAgICAqIHN1Y2ggYXMgc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gXCJsYW5nc21pdGhcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgICAgKlxuICAgICAqIHRyeSB7XG4gICAgICogICAvLyBUcmFjaW5nIGhhcHBlbnMgaGVyZVxuICAgICAqICAgLi4uXG4gICAgICogfSBmaW5hbGx5IHtcbiAgICAgKiAgIGF3YWl0IGNsaWVudC5hd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFsbCBjdXJyZW50bHkgcGVuZGluZyB0cmFjZXMgaGF2ZSBzZW50LlxuICAgICAqL1xuICAgIGF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcygpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubWFwKCh7IGl0ZW1Qcm9taXNlIH0pID0+IGl0ZW1Qcm9taXNlKSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/env.js":
/*!********************************************!*\
  !*** ./node_modules/langsmith/dist/env.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\"TRACING_V2\", \"TRACING\"];\n    return !!envVars.find((envVar) => (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEVBQStCO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9lbnYuanM/ZTMwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5leHBvcnQgY29uc3QgaXNUcmFjaW5nRW5hYmxlZCA9ICh0cmFjaW5nRW5hYmxlZCkgPT4ge1xuICAgIGlmICh0cmFjaW5nRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgY29uc3QgZW52VmFycyA9IFtcIlRSQUNJTkdfVjJcIiwgXCJUUkFDSU5HXCJdO1xuICAgIHJldHVybiAhIWVudlZhcnMuZmluZCgoZW52VmFyKSA9PiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKGVudlZhcikgPT09IFwidHJ1ZVwiKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.1.68\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxQztBQUNJO0FBQzJCO0FBQ3BFO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L2luZGV4LmpzP2M4NTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5leHBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcIi4vcnVuX3RyZWVzLmpzXCI7XG5leHBvcnQgeyBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG4vLyBVcGRhdGUgdXNpbmcgeWFybiBidW1wLXZlcnNpb25cbmV4cG9ydCBjb25zdCBfX3ZlcnNpb25fXyA9IFwiMC4xLjY4XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/langsmith/dist/env.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./singletons/constants.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/constants.js\");\n\n\n\n\n\n\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return (stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId);\n}\n/**\n * Baggage header information\n */\nclass Baggage {\n    constructor(metadata, tags) {\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        for (const item of items) {\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            }\n            else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            }\n        }\n        return new Baggage(metadata, tags);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        return items.join(\",\");\n    }\n}\nclass RunTree {\n    constructor(originalConfig) {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, { ...originalConfig });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata,\n        };\n        config.extra = { ...config.extra, metadata: dedupedMetadata };\n        Object.assign(this, { ...defaultConfig, ...config, client });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            }\n            else {\n                this.trace_id = this.id;\n            }\n        }\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        if (!this.dotted_order) {\n            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order =\n                    this.parent_run.dotted_order + \".\" + currentDottedOrder;\n            }\n            else {\n                this.dotted_order = currentDottedOrder;\n            }\n        }\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            run_type: \"chain\",\n            project_name: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ??\n                (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n                \"default\",\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {},\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order,\n        });\n        // Copy context vars over into the new run tree.\n        if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY] =\n                this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ??\n            this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = { ...presentConfig };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks)\n                ? newConfig.callbacks.copy?.()\n                : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, { _parentRunId: child.id });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers\n                    ?.find(isLangChainTracerLike)\n                    ?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while (current != null && !visited.has(current.id)) {\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra\n                ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } }\n                : { metadata };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        if (!runExtra.runtime) {\n            runExtra.runtime = {};\n        }\n        if (runtimeEnv) {\n            for (const [k, v] of Object.entries(runtimeEnv)) {\n                if (!runExtra.runtime[k]) {\n                    runExtra.runtime[k] = v;\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        }\n        else {\n            parent_run_id = run.parent_run?.id;\n            child_runs = [];\n        }\n        const persistedRun = {\n            id: run.id,\n            name: run.name,\n            start_time: run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags,\n        };\n        return persistedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        try {\n            const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();\n            const runCreate = await this._convertToCreate(this, runtimeEnv, true);\n            await this.client.createRun(runCreate);\n            if (!excludeChildRuns) {\n                (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_3__.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs) {\n                    await childRun.postRun(false);\n                }\n            }\n        }\n        catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun() {\n        try {\n            const runUpdate = {\n                end_time: this.end_time,\n                error: this.error,\n                inputs: this.inputs,\n                outputs: this.outputs,\n                parent_run_id: this.parent_run?.id,\n                reference_example_id: this.reference_example_id,\n                extra: this.extra,\n                events: this.events,\n                dotted_order: this.dotted_order,\n                trace_id: this.trace_id,\n                tags: this.tags,\n            };\n            await this.client.updateRun(this.id, runUpdate);\n        }\n        catch (error) {\n            console.error(`Error in patchRun for run ${this.id}`, error);\n        }\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_2__.isTracingEnabled)();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName,\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? [])),\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata,\n                },\n            },\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({ \"langsmith-trace\": dottedOrder });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\"\n            ? {\n                \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n                baggage: headers.get(\"baggage\"),\n            }\n            : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\")\n            return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part) => {\n            const [strTime, uuid] = part.split(\"Z\");\n            return { strTime, time: Date.parse(strTime + \"Z\"), uuid };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder,\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n        }\n        return new RunTree(config);\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags).toHeader(),\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)) {\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nfunction isRunTree(x) {\n    return (x !== undefined &&\n        typeof x.createChild === \"function\" &&\n        typeof x.postRun === \"function\");\n}\nfunction isLangChainTracerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        typeof x.name === \"string\" &&\n        x.name === \"langchain_tracer\");\n}\nfunction containsLangChainTracerLike(x) {\n    return (Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback)));\n}\nfunction isCallbackManagerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        Array.isArray(x.handlers));\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    return (x !== undefined &&\n        typeof x.callbacks === \"object\" &&\n        // Callback manager with a langchain tracer\n        (containsLangChainTracerLike(x.callbacks?.handlers) ||\n            // Or it's an array with a LangChainTracerLike object within it\n            containsLangChainTracerLike(x.callbacks)));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDbUQ7QUFDM0M7QUFDTztBQUNEO0FBQzJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQyxFQUFFLFlBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtEQUFrRDtBQUMvRjtBQUNBO0FBQ0EseUNBQXlDLHdDQUF3QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQ0FBZ0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3J1bl90cmVlcy5qcz9mODIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgaXNUcmFjaW5nRW5hYmxlZCB9IGZyb20gXCIuL2Vudi5qc1wiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi91dGlscy93YXJuLmpzXCI7XG5pbXBvcnQgeyBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9jb25zdGFudHMuanNcIjtcbmZ1bmN0aW9uIHN0cmlwTm9uQWxwaGFudW1lcmljKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1stOi5dL2csIFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KGVwb2NoLCBydW5JZCwgZXhlY3V0aW9uT3JkZXIgPSAxKSB7XG4gICAgLy8gRGF0ZSBvbmx5IGhhcyBtaWxsaXNlY29uZCBwcmVjaXNpb24sIHNvIHdlIHVzZSB0aGUgbWljcm9zZWNvbmRzIHRvIGJyZWFrXG4gICAgLy8gcG9zc2libGUgdGllcywgYXZvaWRpbmcgaW5jb3JyZWN0IHJ1biBvcmRlclxuICAgIGNvbnN0IHBhZGRlZE9yZGVyID0gZXhlY3V0aW9uT3JkZXIudG9GaXhlZCgwKS5zbGljZSgwLCAzKS5wYWRTdGFydCgzLCBcIjBcIik7XG4gICAgcmV0dXJuIChzdHJpcE5vbkFscGhhbnVtZXJpYyhgJHtuZXcgRGF0ZShlcG9jaCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAtMSl9JHtwYWRkZWRPcmRlcn1aYCkgKyBydW5JZCk7XG59XG4vKipcbiAqIEJhZ2dhZ2UgaGVhZGVyIGluZm9ybWF0aW9uXG4gKi9cbmNsYXNzIEJhZ2dhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhLCB0YWdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgIGxldCB0YWdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdXJpVmFsdWVdID0gaXRlbS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmlWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC1tZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtdGFnc1wiKSB7XG4gICAgICAgICAgICAgICAgdGFncyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJhZ2dhZ2UobWV0YWRhdGEsIHRhZ3MpO1xuICAgIH1cbiAgICB0b0hlYWRlcigpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgJiYgT2JqZWN0LmtleXModGhpcy5tZXRhZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChgbGFuZ3NtaXRoLW1ldGFkYXRhPSR7ZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHRoaXMubWV0YWRhdGEpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50YWdzICYmIHRoaXMudGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtdGFncz0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnRhZ3Muam9pbihcIixcIikpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcy5qb2luKFwiLFwiKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVuVHJlZSB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5fdHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0X25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50X3J1blwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZF9ydW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXJ0X3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kX3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXh0cmFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJpYWxpemVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmVyZW5jZV9leGFtcGxlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2VfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG90dGVkX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdFbmFibGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4ZWN1dGlvbl9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZF9leGVjdXRpb25fb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgeW91IHBhc3MgaW4gYSBydW4gdHJlZSBkaXJlY3RseSwgcmV0dXJuIGEgc2hhbGxvdyBjbG9uZVxuICAgICAgICBpZiAoaXNSdW5UcmVlKG9yaWdpbmFsQ29uZmlnKSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLm9yaWdpbmFsQ29uZmlnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBSdW5UcmVlLmdldERlZmF1bHRDb25maWcoKTtcbiAgICAgICAgY29uc3QgeyBtZXRhZGF0YSwgLi4uY29uZmlnIH0gPSBvcmlnaW5hbENvbmZpZztcbiAgICAgICAgY29uc3QgY2xpZW50ID0gY29uZmlnLmNsaWVudCA/PyBSdW5UcmVlLmdldFNoYXJlZENsaWVudCgpO1xuICAgICAgICBjb25zdCBkZWR1cGVkTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLmNvbmZpZz8uZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgICBjb25maWcuZXh0cmEgPSB7IC4uLmNvbmZpZy5leHRyYSwgbWV0YWRhdGE6IGRlZHVwZWRNZXRhZGF0YSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgLi4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnLCBjbGllbnQgfSk7XG4gICAgICAgIGlmICghdGhpcy50cmFjZV9pZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLnBhcmVudF9ydW4udHJhY2VfaWQgPz8gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uX29yZGVyID8/PSAxO1xuICAgICAgICB0aGlzLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA/Pz0gMTtcbiAgICAgICAgaWYgKCF0aGlzLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERvdHRlZE9yZGVyID0gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQodGhpcy5zdGFydF90aW1lLCB0aGlzLmlkLCB0aGlzLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9ydW4uZG90dGVkX29yZGVyICsgXCIuXCIgKyBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5fdHlwZTogXCJjaGFpblwiLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1BST0pFQ1RcIikgPz9cbiAgICAgICAgICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1NFU1NJT05cIikgPz8gLy8gVE9ETzogRGVwcmVjYXRlXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGFwaV91cmw6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz8gXCJodHRwOi8vbG9jYWxob3N0OjE5ODRcIixcbiAgICAgICAgICAgIGFwaV9rZXk6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKSxcbiAgICAgICAgICAgIGNhbGxlcl9vcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB7fSxcbiAgICAgICAgICAgIGlucHV0czoge30sXG4gICAgICAgICAgICBleHRyYToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaGFyZWRDbGllbnQoKSB7XG4gICAgICAgIGlmICghUnVuVHJlZS5zaGFyZWRDbGllbnQpIHtcbiAgICAgICAgICAgIFJ1blRyZWUuc2hhcmVkQ2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSdW5UcmVlLnNoYXJlZENsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IHRoaXMuY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiB0aGlzLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZDogdGhpcy50cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBjaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb3B5IGNvbnRleHQgdmFycyBvdmVyIGludG8gdGhlIG5ldyBydW4gdHJlZS5cbiAgICAgICAgaWYgKF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgaW4gdGhpcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNoaWxkW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldID1cbiAgICAgICAgICAgICAgICB0aGlzW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IExDX0NISUxEID0gU3ltYm9sLmZvcihcImxjOmNoaWxkX2NvbmZpZ1wiKTtcbiAgICAgICAgY29uc3QgcHJlc2VudENvbmZpZyA9IGNvbmZpZy5leHRyYT8uW0xDX0NISUxEXSA/P1xuICAgICAgICAgICAgdGhpcy5leHRyYVtMQ19DSElMRF07XG4gICAgICAgIC8vIHRyYWNpbmcgZm9yIExhbmdDaGFpbiBpcyBkZWZpbmVkIGJ5IHRoZSBfcGFyZW50UnVuSWQgYW5kIHJ1bk1hcCBvZiB0aGUgdHJhY2VyXG4gICAgICAgIGlmIChpc1J1bm5hYmxlQ29uZmlnTGlrZShwcmVzZW50Q29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29uZmlnID0geyAuLi5wcmVzZW50Q29uZmlnIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBpc0NhbGxiYWNrTWFuYWdlckxpa2UobmV3Q29uZmlnLmNhbGxiYWNrcylcbiAgICAgICAgICAgICAgICA/IG5ld0NvbmZpZy5jYWxsYmFja3MuY29weT8uKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhcmVudCBydW4gaWRcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNhbGxiYWNrcywgeyBfcGFyZW50UnVuSWQ6IGNoaWxkLmlkIH0pO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcG9wdWxhdGUgaWYgd2UncmUgaW4gYSBuZXdlciBMQy5KUyB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgID8uZmluZChpc0xhbmdDaGFpblRyYWNlckxpa2UpXG4gICAgICAgICAgICAgICAgICAgID8udXBkYXRlRnJvbVJ1blRyZWU/LihjaGlsZCk7XG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLmV4dHJhW0xDX0NISUxEXSA9IG5ld0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wYWdhdGUgY2hpbGRfZXhlY3V0aW9uX29yZGVyIHVwd2FyZHNcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50LmlkKSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudC5pZCk7XG4gICAgICAgICAgICBjdXJyZW50LmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KGN1cnJlbnQuY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBjaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50X3J1bjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkX3J1bnMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dHMsIGVycm9yLCBlbmRUaW1lID0gRGF0ZS5ub3coKSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gdGhpcy5vdXRwdXRzID8/IG91dHB1dHM7XG4gICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLmVycm9yID8/IGVycm9yO1xuICAgICAgICB0aGlzLmVuZF90aW1lID0gdGhpcy5lbmRfdGltZSA/PyBlbmRUaW1lO1xuICAgICAgICBpZiAobWV0YWRhdGEgJiYgT2JqZWN0LmtleXMobWV0YWRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmEgPSB0aGlzLmV4dHJhXG4gICAgICAgICAgICAgICAgPyB7IC4uLnRoaXMuZXh0cmEsIG1ldGFkYXRhOiB7IC4uLnRoaXMuZXh0cmEubWV0YWRhdGEsIC4uLm1ldGFkYXRhIH0gfVxuICAgICAgICAgICAgICAgIDogeyBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb252ZXJ0VG9DcmVhdGUocnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBydW5FeHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lKSB7XG4gICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bnRpbWVFbnYpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bnRpbWVFbnYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWVba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zKSk7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHJ1bi5wYXJlbnRfcnVuPy5pZDtcbiAgICAgICAgICAgIGNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZXJzaXN0ZWRSdW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgIGV4dHJhOiBydW5FeHRyYSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHJ1bi5zZXJpYWxpemVkLFxuICAgICAgICAgICAgZXJyb3I6IHJ1bi5lcnJvcixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiBydW4ucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogY2hpbGRfcnVucyxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudF9ydW5faWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZWRSdW47XG4gICAgfVxuICAgIGFzeW5jIHBvc3RSdW4oZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCBydW50aW1lRW52LCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUpO1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UoXCJQb3N0aW5nIHdpdGggZXhjbHVkZUNoaWxkUnVucz1mYWxzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiB0aGlzLmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hpbGRSdW4ucG9zdFJ1bihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gcG9zdFJ1biBmb3IgcnVuICR7dGhpcy5pZH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdGNoUnVuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnVuVXBkYXRlID0ge1xuICAgICAgICAgICAgICAgIGVuZF90aW1lOiB0aGlzLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHRoaXMucGFyZW50X3J1bj8uaWQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICAgICAgZXh0cmE6IHRoaXMuZXh0cmEsXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cyxcbiAgICAgICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlX2lkLFxuICAgICAgICAgICAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBhdGNoUnVuIGZvciBydW4gJHt0aGlzLmlkfWAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUnVubmFibGVDb25maWcocGFyZW50Q29uZmlnLCBwcm9wcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhbmRsZSB0aGUgY2FsbGJhY2sgbWFuYWdlciBjYXNlIGZvciBub3dcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gcGFyZW50Q29uZmlnPy5jYWxsYmFja3M7XG4gICAgICAgIGxldCBwYXJlbnRSdW47XG4gICAgICAgIGxldCBwcm9qZWN0TmFtZTtcbiAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgbGV0IHRyYWNpbmdFbmFibGVkID0gaXNUcmFjaW5nRW5hYmxlZCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW5JZCA9IGNhbGxiYWNrTWFuYWdlcj8uZ2V0UGFyZW50UnVuSWQ/LigpID8/IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBsYW5nQ2hhaW5UcmFjZXIgPSBjYWxsYmFja01hbmFnZXI/LmhhbmRsZXJzPy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyPy5uYW1lID09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgICAgIHBhcmVudFJ1biA9IGxhbmdDaGFpblRyYWNlcj8uZ2V0UnVuPy4ocGFyZW50UnVuSWQpO1xuICAgICAgICAgICAgcHJvamVjdE5hbWUgPSBsYW5nQ2hhaW5UcmFjZXI/LnByb2plY3ROYW1lO1xuICAgICAgICAgICAgY2xpZW50ID0gbGFuZ0NoYWluVHJhY2VyPy5jbGllbnQ7XG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCA9IHRyYWNpbmdFbmFibGVkIHx8ICEhbGFuZ0NoYWluVHJhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UnVuVHJlZSA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgIG5hbWU6IHBhcmVudFJ1bi5uYW1lLFxuICAgICAgICAgICAgaWQ6IHBhcmVudFJ1bi5pZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBwYXJlbnRSdW4udHJhY2VfaWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB0YWdzOiBbXG4gICAgICAgICAgICAgICAgLi4ubmV3IFNldCgocGFyZW50UnVuPy50YWdzID8/IFtdKS5jb25jYXQocGFyZW50Q29uZmlnPy50YWdzID8/IFtdKSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnRSdW4/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyZW50Q29uZmlnPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJlbnRSdW5UcmVlLmNyZWF0ZUNoaWxkKHByb3BzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Eb3R0ZWRPcmRlcihkb3R0ZWRPcmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSGVhZGVycyh7IFwibGFuZ3NtaXRoLXRyYWNlXCI6IGRvdHRlZE9yZGVyIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcnMoaGVhZGVycywgaW5oZXJpdEFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmF3SGVhZGVycyA9IFwiZ2V0XCIgaW4gaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycy5nZXQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgXCJsYW5nc21pdGgtdHJhY2VcIjogaGVhZGVycy5nZXQoXCJsYW5nc21pdGgtdHJhY2VcIiksXG4gICAgICAgICAgICAgICAgYmFnZ2FnZTogaGVhZGVycy5nZXQoXCJiYWdnYWdlXCIpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBoZWFkZXJzO1xuICAgICAgICBjb25zdCBoZWFkZXJUcmFjZSA9IHJhd0hlYWRlcnNbXCJsYW5nc21pdGgtdHJhY2VcIl07XG4gICAgICAgIGlmICghaGVhZGVyVHJhY2UgfHwgdHlwZW9mIGhlYWRlclRyYWNlICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyZW50RG90dGVkT3JkZXIgPSBoZWFkZXJUcmFjZS50cmltKCk7XG4gICAgICAgIGNvbnN0IHBhcnNlZERvdHRlZE9yZGVyID0gcGFyZW50RG90dGVkT3JkZXIuc3BsaXQoXCIuXCIpLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3N0clRpbWUsIHV1aWRdID0gcGFydC5zcGxpdChcIlpcIik7XG4gICAgICAgICAgICByZXR1cm4geyBzdHJUaW1lLCB0aW1lOiBEYXRlLnBhcnNlKHN0clRpbWUgKyBcIlpcIiksIHV1aWQgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSBwYXJzZWREb3R0ZWRPcmRlclswXS51dWlkO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5pbmhlcml0QXJncyxcbiAgICAgICAgICAgIG5hbWU6IGluaGVyaXRBcmdzPy5bXCJuYW1lXCJdID8/IFwicGFyZW50XCIsXG4gICAgICAgICAgICBydW5fdHlwZTogaW5oZXJpdEFyZ3M/LltcInJ1bl90eXBlXCJdID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IGluaGVyaXRBcmdzPy5bXCJzdGFydF90aW1lXCJdID8/IERhdGUubm93KCksXG4gICAgICAgICAgICBpZDogcGFyc2VkRG90dGVkT3JkZXIuYXQoLTEpPy51dWlkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudERvdHRlZE9yZGVyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0gJiYgdHlwZW9mIHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBiYWdnYWdlID0gQmFnZ2FnZS5mcm9tSGVhZGVyKHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdKTtcbiAgICAgICAgICAgIGNvbmZpZy5tZXRhZGF0YSA9IGJhZ2dhZ2UubWV0YWRhdGE7XG4gICAgICAgICAgICBjb25maWcudGFncyA9IGJhZ2dhZ2UudGFncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1blRyZWUoY29uZmlnKTtcbiAgICB9XG4gICAgdG9IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgXCJsYW5nc21pdGgtdHJhY2VcIjogdGhpcy5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBiYWdnYWdlOiBuZXcgQmFnZ2FnZSh0aGlzLmV4dHJhPy5tZXRhZGF0YSwgdGhpcy50YWdzKS50b0hlYWRlcigpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1blRyZWUsIFwic2hhcmVkQ2xpZW50XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbFxufSk7XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5UcmVlKHgpIHtcbiAgICByZXR1cm4gKHggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgeC5jcmVhdGVDaGlsZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiB4LnBvc3RSdW4gPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBpc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB4Lm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgeC5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG59XG5mdW5jdGlvbiBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh4KSAmJiB4LnNvbWUoKGNhbGxiYWNrKSA9PiBpc0xhbmdDaGFpblRyYWNlckxpa2UoY2FsbGJhY2spKSk7XG59XG5mdW5jdGlvbiBpc0NhbGxiYWNrTWFuYWdlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoeC5oYW5kbGVycykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVDb25maWdMaWtlKHgpIHtcbiAgICAvLyBDaGVjayB0aGF0IGl0J3MgYW4gb2JqZWN0IHdpdGggYSBjYWxsYmFja3MgYXJnXG4gICAgLy8gdGhhdCBoYXMgZWl0aGVyIGEgQ2FsbGJhY2tNYW5hZ2VyTGlrZSBvYmplY3Qgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXIgd2l0aGluIGl0XG4gICAgLy8gb3IgYW4gYXJyYXkgd2l0aCBhIExhbmdDaGFpblRyYWNlckxpa2Ugb2JqZWN0IHdpdGhpbiBpdFxuICAgIHJldHVybiAoeCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiB4LmNhbGxiYWNrcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAvLyBDYWxsYmFjayBtYW5hZ2VyIHdpdGggYSBsYW5nY2hhaW4gdHJhY2VyXG4gICAgICAgIChjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeC5jYWxsYmFja3M/LmhhbmRsZXJzKSB8fFxuICAgICAgICAgICAgLy8gT3IgaXQncyBhbiBhcnJheSB3aXRoIGEgTGFuZ0NoYWluVHJhY2VyTGlrZSBvYmplY3Qgd2l0aGluIGl0XG4gICAgICAgICAgICBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeC5jYWxsYmFja3MpKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY)\n/* harmony export */ });\nconst _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL2NvbnN0YW50cy5qcz9iOGUzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZID0gU3ltYm9sLmZvcihcImxjOmNvbnRleHRfdmFyaWFibGVzXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */\nconst overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\n/**\n * @internal\n */\nconst _getFetchImplementation = () => {\n    return (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n        DEFAULT_FETCH_IMPLEMENTATION);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL2ZldGNoLmpzPzM0MjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JhcCB0aGUgZGVmYXVsdCBmZXRjaCBjYWxsIGR1ZSB0byBpc3N1ZXMgd2l0aCBpbGxlZ2FsIGludm9jYXRpb25zXG4vLyBpbiBzb21lIGVudmlyb25tZW50czpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY5ODc2ODU5L3doeS1kb2VzLWJpbmQtZml4LWZhaWxlZC10by1leGVjdXRlLWZldGNoLW9uLXdpbmRvdy1pbGxlZ2FsLWludm9jYXRpb24tZXJyXG4vLyBAdHMtZXhwZWN0LWVycm9yIEJyb2FkIHR5cGluZyB0byBzdXBwb3J0IGEgcmFuZ2Ugb2YgZmV0Y2ggaW1wbGVtZW50YXRpb25zXG5jb25zdCBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OID0gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xuY29uc3QgTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpmZXRjaF9pbXBsZW1lbnRhdGlvblwiKTtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBMYW5nU21pdGggY2FsbHMuXG4gKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBmZXRjaFxuICogb3RoZXIgdGhhbiB0aGUgZGVmYXVsdCBnbG9iYWwgKGUuZy4gZm9yIGRlYWxpbmcgd2l0aCBwcm94aWVzKS5cbiAqIEBwYXJhbSBmZXRjaCBUaGUgbmV3IGZldGNoIGZ1bmN0aW5vIHRvIHVzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG92ZXJyaWRlRmV0Y2hJbXBsZW1lbnRhdGlvbiA9IChmZXRjaCkgPT4ge1xuICAgIGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV0gPSBmZXRjaDtcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgX2dldEZldGNoSW1wbGVtZW50YXRpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIChnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID8/XG4gICAgICAgIERFRkFVTFRfRkVUQ0hfSU1QTEVNRU5UQVRJT04pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* binding */ ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* binding */ withRunTree)\n/* harmony export */ });\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n/**\n * Return the current run tree from within a traceable-wrapped function.\n * Will throw an error if called outside of a traceable function.\n *\n * @returns The run tree for the given context.\n */\nconst getCurrentRunTree = () => {\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!(0,_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree)(runTree)) {\n        throw new Error([\n            \"Could not get the current run tree.\",\n            \"\",\n            \"Please make sure you are calling this method within a traceable function or the tracing is enabled.\",\n        ].join(\"\\n\"));\n    }\n    return runTree;\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject) => {\n        storage.run(runTree, () => void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nconst ROOT = Symbol.for(\"langsmith:traceable:root\");\nfunction isTraceableFunction(x\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxTQUFTLHdEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL3RyYWNlYWJsZS5qcz80ZjRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUnVuVHJlZSB9IGZyb20gXCIuLi9ydW5fdHJlZXMuanNcIjtcbmNsYXNzIE1vY2tBc3luY0xvY2FsU3RvcmFnZSB7XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJ1bihfLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBUUkFDSU5HX0FMU19LRVkgPSBTeW1ib2wuZm9yKFwibHM6dHJhY2luZ19hc3luY19sb2NhbF9zdG9yYWdlXCIpO1xuY29uc3QgbW9ja0FzeW5jTG9jYWxTdG9yYWdlID0gbmV3IE1vY2tBc3luY0xvY2FsU3RvcmFnZSgpO1xuY2xhc3MgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlciB7XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPz8gbW9ja0FzeW5jTG9jYWxTdG9yYWdlO1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaWYgKGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyKCk7XG4vKipcbiAqIFJldHVybiB0aGUgY3VycmVudCBydW4gdHJlZSBmcm9tIHdpdGhpbiBhIHRyYWNlYWJsZS13cmFwcGVkIGZ1bmN0aW9uLlxuICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgb3V0c2lkZSBvZiBhIHRyYWNlYWJsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyBUaGUgcnVuIHRyZWUgZm9yIHRoZSBnaXZlbiBjb250ZXh0LlxuICovXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFJ1blRyZWUgPSAoKSA9PiB7XG4gICAgY29uc3QgcnVuVHJlZSA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5nZXRTdG9yZSgpO1xuICAgIGlmICghaXNSdW5UcmVlKHJ1blRyZWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICBcIkNvdWxkIG5vdCBnZXQgdGhlIGN1cnJlbnQgcnVuIHRyZWUuXCIsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCJQbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoaW4gYSB0cmFjZWFibGUgZnVuY3Rpb24gb3IgdGhlIHRyYWNpbmcgaXMgZW5hYmxlZC5cIixcbiAgICAgICAgXS5qb2luKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1blRyZWU7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiB3aXRoUnVuVHJlZShydW5UcmVlLCBmbikge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldEluc3RhbmNlKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc3RvcmFnZS5ydW4ocnVuVHJlZSwgKCkgPT4gdm9pZCBQcm9taXNlLnJlc29sdmUoZm4oKSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBST09UID0gU3ltYm9sLmZvcihcImxhbmdzbWl0aDp0cmFjZWFibGU6cm9vdFwiKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1RyYWNlYWJsZUZ1bmN0aW9uKHhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiAmJiBcImxhbmdzbWl0aDp0cmFjZWFibGVcIiBpbiB4O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertUuid: () => (/* binding */ assertUuid)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction assertUuid(str, which) {\n    if (!uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"](str)) {\n        const msg = which !== undefined\n            ? `Invalid UUID for ${which}: ${str}`\n            : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkI7QUFDdEI7QUFDUCxTQUFTLDRDQUFhO0FBQ3RCO0FBQ0Esa0NBQWtDLE1BQU0sSUFBSSxJQUFJO0FBQ2hELCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9fdXVpZC5qcz83YmNiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVdWlkKHN0ciwgd2hpY2gpIHtcbiAgICBpZiAoIXV1aWQudmFsaWRhdGUoc3RyKSkge1xuICAgICAgICBjb25zdCBtc2cgPSB3aGljaCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGBJbnZhbGlkIFVVSUQgZm9yICR7d2hpY2h9OiAke3N0cn1gXG4gICAgICAgICAgICA6IGBJbnZhbGlkIFVVSUQ6ICR7c3RyfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n\n\n\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    408, // Request Timeout\n];\nconst STATUS_IGNORE = [\n    409, // Conflict\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt(error) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const response = error?.response;\n                const status = response?.status;\n                if (status) {\n                    if (STATUS_NO_RETRY.includes(+status)) {\n                        throw error;\n                    }\n                    else if (STATUS_IGNORE.includes(+status)) {\n                        return;\n                    }\n                    if (onFailedResponseHook) {\n                        await onFailedResponseHook(response);\n                    }\n                }\n            },\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(() => (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__._getFetchImplementation)()(...args).then((res) => res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDRztBQUNpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksS0FBc0I7QUFDbEM7QUFDQSw2QkFBNkIsK0NBQWlCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBUyxHQUFHLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZFQUF1QjtBQUN0RDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbGlmaWNhdGlvbi1hZ2VudC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9hc3luY19jYWxsZXIuanM/MmNkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5pbXBvcnQgeyBfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLCAvLyBCYWQgUmVxdWVzdFxuICAgIDQwMSwgLy8gVW5hdXRob3JpemVkXG4gICAgNDAzLCAvLyBGb3JiaWRkZW5cbiAgICA0MDQsIC8vIE5vdCBGb3VuZFxuICAgIDQwNSwgLy8gTWV0aG9kIE5vdCBBbGxvd2VkXG4gICAgNDA2LCAvLyBOb3QgQWNjZXB0YWJsZVxuICAgIDQwNywgLy8gUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcbiAgICA0MDgsIC8vIFJlcXVlc3QgVGltZW91dFxuXTtcbmNvbnN0IFNUQVRVU19JR05PUkUgPSBbXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRSZXNwb25zZUhvb2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rID0gcGFyYW1zPy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9uRmFpbGVkUmVzcG9uc2VIb29rID0gdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXN5bmMgb25GYWlsZWRBdHRlbXB0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUaW1lb3V0RXJyb3JcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnJvcj8ucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2U/LnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNUQVRVU19JR05PUkUuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob25GYWlsZWRSZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG9uRmFpbGVkUmVzcG9uc2VIb29rKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSguLi5hcmdzKS50aGVuKChyZXMpID0+IHJlcy5vayA/IHJlcyA6IFByb21pc2UucmVqZWN0KHJlcykpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" &&\n        (navigator.userAgent.includes(\"Node.js\") ||\n            navigator.userAgent.includes(\"jsdom\")));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !isDeno();\nconst getEnv = () => {\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    }\n    else if (isNode()) {\n        globalEnv = \"node\";\n    }\n    else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    }\n    else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    }\n    else if (isDeno()) {\n        globalEnv = \"deno\";\n    }\n    else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nfunction getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv,\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */\nfunction getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)) {\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for (const key in envVars) {\n        if ((key.toLowerCase().includes(\"key\") ||\n            key.toLowerCase().includes(\"secret\") ||\n            key.toLowerCase().includes(\"token\")) &&\n            typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] =\n                value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */\nfunction getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\",\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)) {\n        if (key.startsWith(\"LANGCHAIN_\") &&\n            typeof value === \"string\" &&\n            !excluded.includes(key) &&\n            !key.toLowerCase().includes(\"key\") &&\n            !key.toLowerCase().includes(\"secret\") &&\n            !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            }\n            else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */\nfunction getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value]) => {\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    }\n    catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nfunction getLangSmithEnvironmentVariable(name) {\n    return (getEnvironmentVariable(`LANGSMITH_${name}`) ||\n        getEnvironmentVariable(`LANGCHAIN_${name}`));\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */\nfunction getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\",\n    ];\n    const shas = {};\n    for (const env of common_release_envs) {\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBDO0FBQzFDO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdEQUFnRCxLQUFLO0FBQ3JELDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Vudi5qcz8yN2NmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIElubGluZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmxleGRpbmVzaC9icm93c2VyLW9yLW5vZGVcbmltcG9ydCB7IF9fdmVyc2lvbl9fIH0gZnJvbSBcIi4uL2luZGV4LmpzXCI7XG5sZXQgZ2xvYmFsRW52O1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydCBjb25zdCBpc1dlYldvcmtlciA9ICgpID0+IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3RvciAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZVwiO1xuZXhwb3J0IGNvbnN0IGlzSnNEb20gPSAoKSA9PiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubmFtZSA9PT0gXCJub2RlanNcIikgfHxcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk5vZGUuanNcIikgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJqc2RvbVwiKSkpO1xuLy8gU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBwcm92aWRlcyBhIGBEZW5vYCBnbG9iYWwgb2JqZWN0XG4vLyB3aXRob3V0IGB2ZXJzaW9uYCBwcm9wZXJ0eVxuZXhwb3J0IGNvbnN0IGlzRGVubyA9ICgpID0+IHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gTWFyayBub3QtYXMtbm9kZSBpZiBpbiBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uXG5leHBvcnQgY29uc3QgaXNOb2RlID0gKCkgPT4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAhaXNEZW5vKCk7XG5leHBvcnQgY29uc3QgZ2V0RW52ID0gKCkgPT4ge1xuICAgIGlmIChnbG9iYWxFbnYpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbEVudjtcbiAgICB9XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiYnJvd3NlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05vZGUoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIm5vZGVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNXZWJXb3JrZXIoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIndlYndvcmtlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0pzRG9tKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJqc2RvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Rlbm8oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImRlbm9cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwib3RoZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbEVudjtcbn07XG5sZXQgcnVudGltZUVudmlyb25tZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpIHtcbiAgICBpZiAocnVudGltZUVudmlyb25tZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZW52ID0gZ2V0RW52KCk7XG4gICAgICAgIGNvbnN0IHJlbGVhc2VFbnYgPSBnZXRTaGFzKCk7XG4gICAgICAgIHJ1bnRpbWVFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgIGxpYnJhcnk6IFwibGFuZ3NtaXRoXCIsXG4gICAgICAgICAgICBydW50aW1lOiBlbnYsXG4gICAgICAgICAgICBzZGs6IFwibGFuZ3NtaXRoLWpzXCIsXG4gICAgICAgICAgICBzZGtfdmVyc2lvbjogX192ZXJzaW9uX18sXG4gICAgICAgICAgICAuLi5yZWxlYXNlRW52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcnVudGltZUVudmlyb25tZW50O1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIExhbmdDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICogU2Vuc2l0aXZlIGtleXMgKGNvbnRhaW5pbmcgdGhlIHdvcmQgXCJrZXlcIiwgXCJ0b2tlblwiLCBvciBcInNlY3JldFwiKSBoYXZlIHRoZWlyIHZhbHVlcyByZWRhY3RlZCBmb3Igc2VjdXJpdHkuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiAgLSBBIHJlY29yZCBvZiBMYW5nQ2hhaW4tc3BlY2lmaWMgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ0NoYWluRW52VmFycygpIHtcbiAgICBjb25zdCBhbGxFbnZWYXJzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB8fCB7fTtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiTEFOR0NIQUlOX1wiKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGVudlZhcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGVudlZhcnMpIHtcbiAgICAgICAgaWYgKChrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImtleVwiKSB8fFxuICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgfHxcbiAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidG9rZW5cIikpICYmXG4gICAgICAgICAgICB0eXBlb2YgZW52VmFyc1trZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVudlZhcnNba2V5XTtcbiAgICAgICAgICAgIGVudlZhcnNba2V5XSA9XG4gICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgMikgKyBcIipcIi5yZXBlYXQodmFsdWUubGVuZ3RoIC0gNCkgKyB2YWx1ZS5zbGljZSgtMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudlZhcnM7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTGFuZ0NoYWluLXNwZWNpZmljIG1ldGFkYXRhIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi1zcGVjaWZpYyBtZXRhZGF0YSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEoKSB7XG4gICAgY29uc3QgYWxsRW52VmFycyA9IGdldEVudmlyb25tZW50VmFyaWFibGVzKCkgfHwge307XG4gICAgY29uc3QgZW52VmFycyA9IHt9O1xuICAgIGNvbnN0IGV4Y2x1ZGVkID0gW1xuICAgICAgICBcIkxBTkdDSEFJTl9BUElfS0VZXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX0VORFBPSU5UXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1RSQUNJTkdfVjJcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fUFJPSkVDVFwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9TRVNTSU9OXCIsXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICFleGNsdWRlZC5pbmNsdWRlcyhrZXkpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidG9rZW5cIikpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiTEFOR0NIQUlOX1JFVklTSU9OX0lEXCIpIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW1wicmV2aXNpb25faWRcIl0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudlZhcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBvcGVyYXRlIGluIGEgdmFyaWV0eSBvZiBKUyBlbnZpcm9ubWVudHMsXG4gKiBpbmNsdWRpbmcgTm9kZS5qcywgRGVubywgYnJvd3NlcnMsIGV0Yy5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZH1cbiAqICAtIEEgcmVjb3JkIG9mIGVudmlyb25tZW50IHZhcmlhYmxlcyBpZiBhdmFpbGFibGUuXG4gKiAgLSBgdW5kZWZpbmVkYCBpZiB0aGUgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBvciBhbGxvd3MgYWNjZXNzIHRvIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGVzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHByb2Nlc3MuZW52KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGJyb3dzZXJzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMsIHdlIG1heSBub3QgaGF2ZSBkaXJlY3QgYWNjZXNzIHRvIGVudiB2YXJpYWJsZXNcbiAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBvciBhbnkgb3RoZXIgZmFsbGJhY2sgYXMgcmVxdWlyZWQuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIENhdGNoIGFueSBlcnJvcnMgdGhhdCBtaWdodCBvY2N1ciB3aGlsZSB0cnlpbmcgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUpIHtcbiAgICAvLyBDZXJ0YWluIERlbm8gc2V0dXBzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeSB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2h3Y2hhc2UxNy9sYW5nY2hhaW5qcy9pc3N1ZXMvMTQxMlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudj8uW25hbWVdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgcmV0dXJuIChnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGBMQU5HU01JVEhfJHtuYW1lfWApIHx8XG4gICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoYExBTkdDSEFJTl8ke25hbWV9YCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIHByb2Nlc3MuZW52W25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxubGV0IGNhY2hlZENvbW1pdFNIQXM7XG4vKipcbiAqIEdldCB0aGUgR2l0IGNvbW1pdCBTSEEgZnJvbSBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiB1c2VkIGJ5IGRpZmZlcmVudCBDSS9DRCBwbGF0Zm9ybXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgR2l0IGNvbW1pdCBTSEEgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXMoKSB7XG4gICAgaWYgKGNhY2hlZENvbW1pdFNIQXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQ29tbWl0U0hBcztcbiAgICB9XG4gICAgY29uc3QgY29tbW9uX3JlbGVhc2VfZW52cyA9IFtcbiAgICAgICAgXCJWRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJORVhUX1BVQkxJQ19WRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDT01NSVRfUkVGXCIsXG4gICAgICAgIFwiUkVOREVSX0dJVF9DT01NSVRcIixcbiAgICAgICAgXCJDSV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ0lSQ0xFX1NIQTFcIixcbiAgICAgICAgXCJDRl9QQUdFU19DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiUkVBQ1RfQVBQX0dJVF9TSEFcIixcbiAgICAgICAgXCJTT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgICBcIkdJVEhVQl9TSEFcIixcbiAgICAgICAgXCJUUkFWSVNfQ09NTUlUXCIsXG4gICAgICAgIFwiR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkJVSUxEX1ZDU19OVU1CRVJcIixcbiAgICAgICAgXCJiYW1ib29fcGxhblJlcG9zaXRvcnlfcmV2aXNpb25cIixcbiAgICAgICAgXCJCdWlsZC5Tb3VyY2VWZXJzaW9uXCIsXG4gICAgICAgIFwiQklUQlVDS0VUX0NPTU1JVFwiLFxuICAgICAgICBcIkRST05FX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgICBcIkJVSUxES0lURV9DT01NSVRcIixcbiAgICBdO1xuICAgIGNvbnN0IHNoYXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVudiBvZiBjb21tb25fcmVsZWFzZV9lbnZzKSB7XG4gICAgICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoZW52KTtcbiAgICAgICAgaWYgKGVudlZhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGFzW2Vudl0gPSBlbnZWYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVkQ29tbWl0U0hBcyA9IHNoYXM7XG4gICAgcmV0dXJuIHNoYXM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/error.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),\n/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),\n/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)\n/* harmony export */ });\nfunction getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null)\n        return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\")\n        return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nfunction printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null)\n        return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */\nclass LangSmithConflictError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"LangSmithConflictError\";\n    }\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */\nasync function raiseForStatus(response, context, consume) {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    let errorBody;\n    if (response.ok) {\n        if (consume) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    errorBody = await response.text();\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    throw new Error(fullMessage);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRLHFCQUFxQixnQkFBZ0IsS0FBSyxvQkFBb0IscUJBQXFCLFVBQVU7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanM/YTE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRFcnJvclN0YWNrVHJhY2UoZSkge1xuICAgIGlmICh0eXBlb2YgZSAhPT0gXCJvYmplY3RcIiB8fCBlID09IG51bGwpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGUpIHx8IHR5cGVvZiBlLnN0YWNrICE9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBzdGFjayA9IGUuc3RhY2s7XG4gICAgY29uc3QgcHJldkxpbmUgPSBgJHtlfWA7XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgocHJldkxpbmUpKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UocHJldkxpbmUubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RXJyb3JTdGFja1RyYWNlKGUpIHtcbiAgICBjb25zdCBzdGFjayA9IGdldEVycm9yU3RhY2tUcmFjZShlKTtcbiAgICBpZiAoc3RhY2sgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUuZXJyb3Ioc3RhY2spO1xufVxuLyoqXG4gKiBMYW5nU21pdGhDb25mbGljdEVycm9yXG4gKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IG9jY3VycyB3aGVuIHRoZXJlJ3MgYSBjb25mbGljdCBkdXJpbmcgYW4gb3BlcmF0aW9uLFxuICogdHlwaWNhbGx5IGNvcnJlc3BvbmRpbmcgdG8gSFRUUCA0MDkgc3RhdHVzIGNvZGUgcmVzcG9uc2VzLlxuICpcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gYW4gYXR0ZW1wdCB0byBjcmVhdGUgb3IgbW9kaWZ5IGEgcmVzb3VyY2UgY29uZmxpY3RzXG4gKiB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByZXNvdXJjZSBvbiB0aGUgc2VydmVyLiBDb21tb24gc2NlbmFyaW9zIGluY2x1ZGU6XG4gKiAtIEF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgcmVzb3VyY2UgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICogLSBUcnlpbmcgdG8gdXBkYXRlIGEgcmVzb3VyY2UgdGhhdCBoYXMgYmVlbiBtb2RpZmllZCBieSBhbm90aGVyIHByb2Nlc3NcbiAqIC0gVmlvbGF0aW5nIGEgdW5pcXVlbmVzcyBjb25zdHJhaW50IGluIHRoZSBkYXRhXG4gKlxuICogQGV4dGVuZHMgRXJyb3JcbiAqXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgYXdhaXQgY3JlYXRlUHJvamVjdChcImV4aXN0aW5nUHJvamVjdFwiKTtcbiAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gKiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbmZsaWN0RXJyb3IpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkEgY29uZmxpY3Qgb2NjdXJyZWQ6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICAgIC8vIEhhbmRsZSB0aGUgY29uZmxpY3QsIGUuZy4sIGJ5IHN1Z2dlc3RpbmcgYSBkaWZmZXJlbnQgcHJvamVjdCBuYW1lXG4gKiAgIH0gZWxzZSB7XG4gKiAgICAgLy8gSGFuZGxlIG90aGVyIHR5cGVzIG9mIGVycm9yc1xuICogICB9XG4gKiB9XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBBbHdheXMgc2V0IHRvICdDb25mbGljdEVycm9yJyBmb3IgZWFzeSBpZGVudGlmaWNhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSBEZXRhaWxlZCBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyBzZXJ2ZXIgcmVzcG9uc2VcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwOVxuICovXG5leHBvcnQgY2xhc3MgTGFuZ1NtaXRoQ29uZmxpY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkxhbmdTbWl0aENvbmZsaWN0RXJyb3JcIjtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyBhbiBhcHByb3ByaWF0ZSBlcnJvciBiYXNlZCBvbiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGFuZCBib2R5LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBmZXRjaCBSZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSBjb250ZXh0IC0gQWRkaXRpb25hbCBjb250ZXh0IHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yIG1lc3NhZ2UgKGUuZy4sIG9wZXJhdGlvbiBiZWluZyBwZXJmb3JtZWQpXG4gKiBAdGhyb3dzIHtMYW5nU21pdGhDb25mbGljdEVycm9yfSBXaGVuIHRoZSByZXNwb25zZSBzdGF0dXMgaXMgNDA5XG4gKiBAdGhyb3dzIHtFcnJvcn0gRm9yIGFsbCBvdGhlciBub24tb2sgcmVzcG9uc2VzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgY29udGV4dCwgY29uc3VtZSkge1xuICAgIC8vIGNvbnN1bWUgdGhlIHJlc3BvbnNlIGJvZHkgdG8gcmVsZWFzZSB0aGUgY29ubmVjdGlvblxuICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgbGV0IGVycm9yQm9keTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKGNvbnN1bWUpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGBGYWlsZWQgdG8gJHtjb250ZXh0fS4gUmVjZWl2ZWQgc3RhdHVzIFske3Jlc3BvbnNlLnN0YXR1c31dOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LiBTZXJ2ZXIgcmVzcG9uc2U6ICR7ZXJyb3JCb2R5fWA7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHRocm93IG5ldyBMYW5nU21pdGhDb25mbGljdEVycm9yKGZ1bGxNZXNzYWdlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGZ1bGxNZXNzYWdlKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* eslint-disable */\n// @ts-nocheck\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = { result: \"[Circular]\" };\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER,\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    try {\n        return JSON.stringify(obj, replacer, spacer);\n    }\n    catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(\"[WARNING]: LangSmith received unserializable value.\");\n            return \"[Unserializable]\";\n        }\n        console.warn(\"[WARNING]: LangSmith received circular JSON. This will decrease tracer performance.\");\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        var res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            }\n            else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        }\n        catch (_) {\n            return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n        }\n        finally {\n            while (arr.length !== 0) {\n                var part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                }\n                else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return res;\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, { value: replace });\n            arr.push([parent, k, val, propertyDescriptor]);\n        }\n        else {\n            replacerStack.push([val, k, replace]);\n        }\n    }\n    else {\n        parent[k] = replace;\n        arr.push([parent, k, val]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            var keys = Object.keys(val);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        // Ensure that we restore the object as it was.\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        }\n        catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([parent, k, val]);\n                parent[k] = tmp;\n            }\n            else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer =\n        typeof replacer !== \"undefined\"\n            ? replacer\n            : function (k, v) {\n                return v;\n            };\n    return function (key, val) {\n        if (replacerStack.length > 0) {\n            for (var i = 0; i < replacerStack.length; i++) {\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YWxpZmljYXRpb24tYWdlbnQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcz82NDg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9IFwiWy4uLl1cIjtcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSB7IHJlc3VsdDogXCJbQ2lyY3VsYXJdXCIgfTtcbnZhciBhcnIgPSBbXTtcbnZhciByZXBsYWNlclN0YWNrID0gW107XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgfTtcbn1cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gbW9yZSBjb21wbGV4IHN0cmluZ2lmeSBpZiBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgICAgaWYgKCFlLm1lc3NhZ2U/LmluY2x1ZGVzKFwiQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTlwiKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddOiBMYW5nU21pdGggcmVjZWl2ZWQgdW5zZXJpYWxpemFibGUgdmFsdWUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiW1Vuc2VyaWFsaXphYmxlXVwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXTogTGFuZ1NtaXRoIHJlY2VpdmVkIGNpcmN1bGFyIEpTT04uIFRoaXMgd2lsbCBkZWNyZWFzZSB0cmFjZXIgcGVyZm9ybWFuY2UuXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGRlY2lyYyhvYmosIFwiXCIsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRSZXBsYWNlKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pO1xuICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxufVxuLy8gU3RhYmxlLXN0cmluZ2lmeVxuZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gICAgfVxuICAgIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgXCJcIiwgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqO1xuICAgIHZhciByZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXCJbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdXCIpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzdG9yZSB0aGUgb2JqZWN0IGFzIGl0IHdhcy5cbiAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gICAgZGVwdGggKz0gMTtcbiAgICB2YXIgaTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdCkge1xuICAgICAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdCkge1xuICAgICAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgICAgICAgICAgICAgcGFyZW50W2tdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG59XG4vLyB3cmFwcyByZXBsYWNlciBmdW5jdGlvbiB0byBoYW5kbGUgdmFsdWVzIHdlIGNvdWxkbid0IHJlcGxhY2Vcbi8vIGFuZCBtYXJrIHRoZW0gYXMgcmVwbGFjZWQgdmFsdWVcbmZ1bmN0aW9uIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpIHtcbiAgICByZXBsYWNlciA9XG4gICAgICAgIHR5cGVvZiByZXBsYWNlciAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyByZXBsYWNlclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJ0WzJdO1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlclN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: { content: message.content },\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs &&\n        Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = { ...message.additional_kwargs };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL21lc3NhZ2VzLmpzPzE5ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzTGFuZ0NoYWluTWVzc2FnZShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSB7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UuX2dldFR5cGUoKSxcbiAgICAgICAgZGF0YTogeyBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfSxcbiAgICB9O1xuICAgIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiBrZXlzIGluIGFkZGl0aW9uYWxfa3dhcmdzXG4gICAgaWYgKG1lc3NhZ2U/LmFkZGl0aW9uYWxfa3dhcmdzICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udmVydGVkLmRhdGEuYWRkaXRpb25hbF9rd2FyZ3MgPSB7IC4uLm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),\n/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/langsmith/node_modules/semver/index.js\");\n\nfunction isVersionGreaterOrEqual(current_version, target_version) {\n    const current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);\n    const target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nfunction parsePromptIdentifier(identifier) {\n    if (!identifier ||\n        identifier.split(\"/\").length > 2 ||\n        identifier.startsWith(\"/\") ||\n        identifier.endsWith(\"/\") ||\n        identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [owner, name, commit];\n    }\n    else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\"-\", ownerNamePart, commit];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEM7QUFDUCxvQkFBb0IsNkNBQVk7QUFDaEMsbUJBQW1CLDZDQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL3Byb21wdHMuanM/MjliMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSBhcyBwYXJzZVZlcnNpb24gfSBmcm9tIFwic2VtdmVyXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNWZXJzaW9uR3JlYXRlck9yRXF1YWwoY3VycmVudF92ZXJzaW9uLCB0YXJnZXRfdmVyc2lvbikge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJzZVZlcnNpb24oY3VycmVudF92ZXJzaW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBwYXJzZVZlcnNpb24odGFyZ2V0X3ZlcnNpb24pO1xuICAgIGlmICghY3VycmVudCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvbiBmb3JtYXQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC5jb21wYXJlKHRhcmdldCkgPj0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVByb21wdElkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGlmICghaWRlbnRpZmllciB8fFxuICAgICAgICBpZGVudGlmaWVyLnNwbGl0KFwiL1wiKS5sZW5ndGggPiAyIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3RhcnRzV2l0aChcIi9cIikgfHxcbiAgICAgICAgaWRlbnRpZmllci5lbmRzV2l0aChcIi9cIikgfHxcbiAgICAgICAgaWRlbnRpZmllci5zcGxpdChcIjpcIikubGVuZ3RoID4gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICB9XG4gICAgY29uc3QgW293bmVyTmFtZVBhcnQsIGNvbW1pdFBhcnRdID0gaWRlbnRpZmllci5zcGxpdChcIjpcIik7XG4gICAgY29uc3QgY29tbWl0ID0gY29tbWl0UGFydCB8fCBcImxhdGVzdFwiO1xuICAgIGlmIChvd25lck5hbWVQYXJ0LmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICBjb25zdCBbb3duZXIsIG5hbWVdID0gb3duZXJOYW1lUGFydC5zcGxpdChcIi9cIiwgMik7XG4gICAgICAgIGlmICghb3duZXIgfHwgIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpZGVudGlmaWVyIGZvcm1hdDogJHtpZGVudGlmaWVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbb3duZXIsIG5hbWUsIGNvbW1pdF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW93bmVyTmFtZVBhcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpZGVudGlmaWVyIGZvcm1hdDogJHtpZGVudGlmaWVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXCItXCIsIG93bmVyTmFtZVBhcnQsIGNvbW1pdF07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/prompts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWFsaWZpY2F0aW9uLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL3dhcm4uanM/NDU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB3YXJuZWRNZXNzYWdlcyA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXdhcm5lZE1lc3NhZ2VzW21lc3NhZ2VdKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgd2FybmVkTWVzc2FnZXNbbWVzc2FnZV0gPSB0cnVlO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/warn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),
/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(rsc)/./node_modules/langsmith/dist/index.js");


/***/ }),

/***/ "(rsc)/./node_modules/langsmith/run_trees.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/run_trees.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),
/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),
/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),
/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)
/* harmony export */ });
/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ "(rsc)/./node_modules/langsmith/dist/run_trees.js");


/***/ }),

/***/ "(rsc)/./node_modules/langsmith/singletons/traceable.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),
/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),
/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),
/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),
/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)
/* harmony export */ });
/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ "(rsc)/./node_modules/langsmith/dist/singletons/traceable.js");


/***/ })

};
;